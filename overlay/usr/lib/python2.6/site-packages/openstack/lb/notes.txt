When changing the protocol of loadbalancer, we must also change the protocol of services under the cover not only the lbvserver's protocol, since nodes don't have a protocol property.
   * Currently, I cannot change the servicetype (protocol) of an lbvserver in Netscaler anyway, so this is irrelevant for now.

The spec allows the loadbalancer's port to be changed, but we cannot change the port of lbvserver or service currently in Netscaler.

[PARTIAL] When adding a new node to a loadBalancer (either during add of loadBalancer, or add of nodes to loadBalancer operation), we must:
  - Get the lbvserver to know which protocol to give the service associated with this node. The service should have the decrypted version of the lbvserver's protocol [DONE]. 
  - We must also get all the services of the current lbvserver to make sure that the assigned nodeId isn't already used by one the lbvserver's services. [DONE]
  - We must check that we are not exceeding the maximum number of nodes per loadbalancer as per the spec (25). [DONE]
  - The spec doesn't allow adding nodes to a loadbalancer using an id. It assumes that a load balancer's nodes are private to it. An extension to the spec, we consider is to be able to 
    share nodes between loadbalancers of the same tenant. So for this, we must generate node Ids that are unique for the whole tenant, not only unique within a loadBalancer, because 
    we want to be able to share nodes between loadBalancers (e.g. HTTP and HTTPS load balancers). So, we need to generate ids per tenant for both the loadbalancers and the nodes.
    So, our current implementation is correct wrt the spec, but the extension needs to deal with things differently.
  

- I'm not allowing protocol of loadBalancer to be set to other values than HTTP, FTP and HTTPS (the others return "not implemented" error), until we figure a correct way to support these.
   * This will need external storage

- The spec considers the "id" immutable (cannot be changed). However, in the prototype today, changing the name of loadbalancer, also changes its id (which shouldn't happen).
   * This will need external storage (to map ids to lbvserver names).


[DONE] When updating an object like a loadbalancer or a node, we remove fields that have the same value as the current value (see _adjust_....()). We need to check if there is still anything to update after this, otherwise we shouldn't dispatch any update, we should just return the current object to the user.


[PARTIAL] Because the mapping layer has got multiple operations for one API operation, I built a batch processing layer that deal with errors and recovers by undoing the previous operations.
   * When building the undo tasks, we need to remove non-updateable (for update ops) and non-addeable fields (for remove ops) from the state of the undo tasks.
   * Because a loadBalancer change, can require several Nitro API calls, we need the an atomic execution mechanism to guarantee consistency. One way could be to lock the loadBalancer record in the DB while there is an operation in progress. Only after the operation is finished is the lock released, and another API call on the same loadBalancer can take place. 
   * We must make sure not leave locks laying around if there is a failure in the middle of an operation (code exceptions, power failure, etc.)


Nitro could be improved in the following areas:
   - More consistency (why is adding/updating/getting bindings is different to getting normal resources).
   - More bulk operations (get an lbvserver services, either just service names or full state of services, adding a service to an lbvserver in one operation (instead of adding service, then creating binding).
   - In order to update a binding (for example to update the "weight"), I have to remove the binding and re-add it with the new "weight" value.   
   - There are a lot of error codes that mean the same thing like "resource not found".


- [DONE] updating loadBalancer Condition:
  * Setting lbvsrever/service state argument to "DISABLED" doesn't put the service into an "OUT OF SERVICE" state. However disabling the service explicitly (CLI command "disable service abc") does !! I thought these were equivalent.

  * There are 2 states for disabled service returned by svrstate !! One called "DOWN OUT OF SERVICE" and the other one simply "OUT OF SERVICE".


- I don't yet manage pools of virtual IPs with different "type"s (PUBLIC vs. SERVICENET)



- I need to be more precise about the errors saying which item was not found (need to correlate netscaler resources back to loadbalancer resources for meaningful errors).



-  Need to have proper scripts to start/stop/restart lb service (we need to use the same model as other openstack services like swift).




- Performance Improvements:

  * I'm retrieving the same entity several times sometimes (one for to be able to undo, another to find information, and another for the GET at the end of an operation)
  * My method of generating unique ids is not very efficient, as I need to find out all used ids before. May be I can use an simpler allocation mechanism.

- Flexibility enhancements
  * Constants such as:
    - Number of Nitro retries 
    - Sleep time between retries
    - max number of nodes per loadbalancer

   should be in config file. We should separate config for loadbalancer (relevant to the spec) versus config data for implementation (nitro config).




- Things to say about the prototype:

  * A lot of thought has gone into making this:

      - Flexible for extensiblity: 

               - Extensibility at 3 levels:
                   * New values for properties (e.g. protocols, algorithms, persistencetypes, etc.)
                   * New attributes (e.g. sureConnect, timeout for persistence)  
                   * New elements can be easily added, validation hooked in, etc., without disturbing the existing framework.
                      - Every element is backup by a state class 
                      - Every element performs validation on its own values.

      - Plugin design: All specifics of Netscaler and Nitro are isolated in an adapter (plugin)                              

      - The framework that deals with validation, XML/JSON, generation of responses, etc. is independent.

      - Undo functionality: All tasks that are done can be undone so a big operation can be undone if something fails.


  


