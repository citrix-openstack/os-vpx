import httplib
import json
import re
import random 


from openstack.common.BadRequestException import BadRequestException
from openstack.common.LoadBalancerFaultException import LoadBalancerFaultException
from openstack.common.ItemNotFoundException import ItemNotFoundException
from openstack.common.ServiceUnavailableException import ServiceUnavailableException
from openstack.common.NotImplementedException import NotImplementedException
from openstack.common.ImplementationErrorException import ImplementationErrorException
from openstack.common.ImmutableEntityException import ImmutableEntityException

from openstack.lb.plugins.netscaler.NitroCallsWrapper import NitroCallsWrapper
from openstack.lb.plugins.netscaler.NitroUtils import NitroUtils
from openstack.lb.plugins.netscaler.NitroTasks import NitroTasks

from openstack.lb.LBVirtualIPState import LBVirtualIPState
from openstack.lb.LBNodeState import LBNodeState
from openstack.lb.LBSessionPersistenceState import LBSessionPersistenceState
from openstack.lb.LBConnectionLoggingState import LBConnectionLoggingState
from openstack.lb.LBConnectionThrottleState import LBConnectionThrottleState
from openstack.lb.LBHealthMonitorState import LBHealthMonitorState
from openstack.lb.LBAccessListState import LBAccessListState

from openstack.lb.plugins.netscaler.NetScalerLoadBalancerState import NetScalerLoadBalancerState
from openstack.lb.plugins.netscaler.NetScalerLBSessionPersistenceState import NetScalerLBSessionPersistenceState
from openstack.lb.plugins.netscaler.NetScalerLBConnectionLoggingState import NetScalerLBConnectionLoggingState
from openstack.lb.plugins.netscaler.NitroLBNodeAdapter import NitroLBNodeAdapter
from openstack.lb.plugins.netscaler.NitroLBHealthMonitorAdapter import NitroLBHealthMonitorAdapter

from openstack.lb.plugins.netscaler.CitrixNetScalerLBNode import CitrixNetScalerLBNode
from openstack.lb.plugins.netscaler.NetScalerLBServiceDB import NetScalerLBServiceDB


ipv4address_pattern = r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b"
ns_xml_namespace = "urn:citrix.com:loadbalancers:v1.0"


class NitroLoadBalancerAdapter(object):


    def __init__(self, lbresource, extensions_enabled=False):

        self.lbresource = lbresource
        self.lbservice = self.lbresource.lbservice
        self.connmanager = self.lbservice.connmanager
        self.logger = self.lbservice.logger 
        self.extensions_enabled = extensions_enabled
        self.db = NetScalerLBServiceDB(self.lbservice)




    def _adjust_lbvserver_state_for_update(self, loadBalancerId, new_state):

        """ First, we'll get from Netscaler the current lbvserver state """
        """ XXX - In Netscaler, we haven't got IDs for resources so our assumption: loadBalancerId == loadBalancer.name """

        resource_type = "lbvserver"
        resource_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId)
 
        self.logger.debug("adjusting the lbvserver state to submit for an update operation. For this we need to get the existing lbvserver")
        current_state = self.nitrowrapper.get_netscaler_entity(resource_type, resource_name)
        

        if "servicetype" in new_state.keys(): 
            if new_state["servicetype"] != current_state["servicetype"]:
                """ XXX - Netscaler doesn't support changing the servicetype of an lbvserver. """
                raise NotImplementedException("Sorry, changing the protocol of the loadBalancer in the current implementation is not supported.")
                                               
            else:
                """ Just remove it since it is the same """
                del new_state["servicetype"]

        if "port" in new_state.keys(): 
            if type(current_state["port"]) is int:
                new_state["port"] = int(new_state["port"])  

            if new_state["port"] != current_state["port"]:
                """ XXX - Netscaler doesn't support changing the port of an lbvserver. """
                raise NotImplementedException("Sorry, changing the port of the loadBalancer in the current implementation is not supported.")
                                                 
            else:
                del new_state["port"]

        if "lbmethod" in new_state.keys():
            if new_state["lbmethod"] == current_state["lbmethod"]:
                del new_state["lbmethod"]

        if self.extensions_enabled:
            """ XXX - Also check for extended properties in the new_state dictionary """


        self.logger.debug("Adjusted state for Updating lbvserver %s is: %s" % (resource_name, str(new_state)))
  
        return new_state


    def _get_new_loadBalancer_object(self):

        return NetScalerLoadBalancerState(self.lbresource)


    def _get_loadbalancer_object_from_lbvserver_entity(self, loadBalancerId, dict_obj):
  
        lbvserver_name = str(dict_obj["name"])

        expected_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId)
 
        if lbvserver_name != expected_name:    
            raise ImplementationError("resource returned not expected...")

        loadBalancer = self._get_new_loadBalancer_object()

        loadBalancer.name = NitroUtils.get_loadBalancer_name(loadBalancerId)

        servicetype = str(dict_obj["servicetype"])

        loadBalancer.protocol = NitroUtils.get_protocol_from_servicetype(servicetype)

        port = str(dict_obj["port"])
        loadBalancer.port = port

        lbmethod = str(dict_obj["lbmethod"])
        loadBalancer.algorithm = NitroUtils.get_algorithm_from_lbmethod(lbmethod) 

        effectivestate = str(dict_obj["effectivestate"])
        loadBalancer.status= NitroUtils.get_loadbalancerstatus_from_state(effectivestate)

        i = 1
 
        loadBalancer.virtualIps=[]
  
        virtualIP = LBVirtualIPState(self.lbresource)

        ipaddress = str(dict_obj["ipv46"])

        virtualIP.address = ipaddress

        self.logger.debug("VIP for loadbalancer %s is %s" % (loadBalancer.name, ipaddress))

        loadBalancer.virtualIps.append(virtualIP)


        """ Get Session Persistence data """
        persistencetype = str(dict_obj["persistencetype"])

        self.logger.debug("persistencetype of lbvserver is %s" % persistencetype)

        if persistencetype != 'NONE': 
            if self.extensions_enabled:
    	        sessionPersistence = NetScalerLBSessionPersistenceState(self.lbresource)
            else:
    	        sessionPersistence = LBSessionPersistenceState(self.lbresource)

            persistencevalue = NitroUtils.get_persistencetype_from_nspersistencetype(persistencetype)
              
            if persistencevalue:
                sessionPersistence.persistenceType = persistencevalue

            if self.extensions_enabled:
                timeout = str(dict_obj["timeout"])
                if timeout != None:
                    sessionPersistence.timeout = timeout

            loadBalancer.sessionPersistence = sessionPersistence

                
        """ Get Connection Logging data """
        """
        if self.extensions_enabled:
    	    loadBalancer.connectionLogging = NetScalerLBConnectionLoggingState(self.lbresource)
        else:
    	    loadBalancer.connectionLogging = LBConnectionLoggingState(self.lbresource)


        appflow = str(dict_obj["appflowlog"])

        if appflow == "ENABLED":
            loadBalancer.connectionLogging.enabled="true"
        else:
            loadBalancer.connectionLogging.enabled="false"

        loadBalancer.connectionThrottle = LBConnectionThrottleState(self.lbresource)

        loadBalancer.connectionThrottle.minConnections = "10"
        loadBalancer.connectionThrottle.maxConnections = "100"
        loadBalancer.connectionThrottle.maxConnectionRate = "50"
        loadBalancer.connectionThrottle.rateInterval = "60"
        """

        if self.lbservice.cluster:
            loadBalancer.cluster = {}
            loadBalancer.cluster["name"] = self.lbservice.cluster
        else:
            loadBalancer.cluster = {}
            loadBalancer.cluster["name"] = "none"
 


        if self.extensions_enabled:

            sc = str(dict_obj["sc"])

            if sc == "ON":
                loadBalancer.sureConnect="true"
            else:
                loadBalancer.sureConnect="false"

            """
            if appflow == "ENABLED":
                loadBalancer.connectionLogging.type="appflow"
            """


        return loadBalancer


    def _extract_loadbalancer(self, results, loadBalancerId):

        lbvserver = NitroTasks.extract_lbvserver_object_from_task_list(results, loadBalancerId)
     
        self.logger.debug("lbvserver object is: %s" % str(lbvserver))
   
        loadBalancer = self._get_loadbalancer_object_from_lbvserver_entity(loadBalancerId, lbvserver)

        return loadBalancer
 
 
    def _extract_nodes(self, results, loadBalancerId, loadBalancer):

        servicebindings = NitroTasks.extract_servicebindings_from_task_list(results)
 
        if servicebindings: 
            task_list = self.nodeadapter.get_netscaler_getservices_tasks(loadBalancerId, loadBalancer, servicebindings)

            results = self.nitrowrapper.process_netscaler_task_list(task_list) 

            services = NitroTasks.extract_services_from_task_list(results, servicebindings)
        else:
            services = None

        if services:
            return self.nodeadapter.get_netscaler_nodes_from_services_and_servicebindings(loadBalancer.id, loadBalancer, services, servicebindings)
        else:
            return None



    def _extract_healthmonitor(self, results, loadBalancerId, loadBalancer):

        monitor_name = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 

        monitor = NitroTasks.extract_monitor_from_task_list(results, monitor_name) 

        if monitor: 
            healthMonitor = self.monitoradapter.get_netscaler_healthmonitor_from_monitor(loadBalancerId, loadBalancer, monitor)

            return healthMonitor
        else: 
            return None
 

    def _set_netscaler_lbvserver_vipaddress(self, lbvserver, virtualIps):

        if not virtualIps: 
            return 

        virtualIp = virtualIps[0]

        lbvserver["ipv46"] = virtualIp.address
  
        return lbvserver
 

    def _set_netscaler_lbvserver_persistencetype(self, lbvserver, sessionPersistence):

        if "persistenceType" in sessionPersistence:
            lbvserver["persistencetype"] = NitroUtils.get_nspersistencetype_from_persistencetype(sessionPersistence.persistenceType)
                        
        if self.extensions_enabled:
            if "timeout" in sessionPersistence:
                lbvserver["timeout"] = sessionPersistence.timeout
        

    def _process_loadBalancer_extensions(self, loadBalancer, key, lbvserver):

        if not self.extensions_enabled:
            return False
     
        if key == "sureConnect":
            sureConnect = loadBalancer.sureConnect
            lbvserver["sc"] = NitroUtils.get_nssureconnect_from_sureconnect(sureConnect)
            return True

        return False


    def _get_netscaler_servicebindings_of_loadBalancer(self, loadBalancerId):

        task = self.nodeadapter.get_netscaler_getservicebindings_task(loadBalancerId, None)

        task_list.append(task)

        results = self.nitrowrapper.process_netscaler_task_list(task_list) 

        servicebindings = NitroTasks.extract_servicebindings_from_task_list(results)

        return servicebindings


    def _get_netscaler_servicenames_of_loadBalancer(self, loadBalancerId):

        """ We need to get the servicebindings to know the names of the services from this loadBalancer """

        servicebindings = NitroUtils.get_servicebindings_of_loadBalancer(self, loadBalancerId)

        servicenames = NitroUtils.get_servicenames_from_servicebindings(servicebindings)

        return servicenames



    def _get_lbvserver_state(self, lbvserver_name, loadBalancer):

        lbvserver = {}

        lbvserver["name"] = lbvserver_name 

        for key in loadBalancer: 
            self.logger.debug("Examining key \"%s\" of loadBalancer payload" % key)

            if key == "_properties":
                continue

            if key == "protocol":
                lbvserver["servicetype"] = NitroUtils.get_servicetype_from_protocol(loadBalancer.protocol)
                """ XXX - We also need to modify the protocol of all the services of this lbvserver!! """
                continue 

            if key == "port":
                lbvserver["port"] = loadBalancer.port
                continue 

            if key == "algorithm":
                algorithm = loadBalancer.algorithm
                lbvserver["lbmethod"] = NitroUtils.get_lbmethod_from_algorithm(algorithm)                
                continue 

            if key == "virtualIps":
                virtualIps = loadBalancer.virtualIps
                self._set_netscaler_lbvserver_vipaddress(lbvserver, virtualIps)                 
                continue            

            if key == "sessionPersistence":
                sessionPersistence = loadBalancer.sessionPersistence
                self._set_netscaler_lbvserver_persistencetype(lbvserver, sessionPersistence)       
                continue
 
            if self._process_loadBalancer_extensions(loadBalancer, key, lbvserver):
                continue

        return lbvserver



    def _get_netscaler_addloadbalancer_task(self, loadBalancerId, loadBalancer):   

        task_list = []

        if not "name" in loadBalancer:
            raise ImplementationError("We should have caught this during validation phase.")


        lbvserver_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId) 

        task = {}
        task["type"] = "lbvserver"
        task["name"] = lbvserver_name
        task["operation"] = "ADD"

        lbvserver = self._get_lbvserver_state(lbvserver_name, loadBalancer)
        task["state"] = lbvserver
        task_list.append(task)

        return task
 

    def _get_netscaler_updateloadbalancer_task(self, loadBalancerId, loadBalancer, newLoadBalancerId=None):   

        task_list = []
 
        self.logger.debug("About to get lbvserver state")

        if newLoadBalancerId:
            lbvserver_name = NitroUtils.get_lbvservername_from_loadbalancerid(newLoadBalancerId)
        else: 
            lbvserver_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId) 

        lbvserver = self._get_lbvserver_state(lbvserver_name, loadBalancer)

        lbvserver = self._adjust_lbvserver_state_for_update(loadBalancerId, lbvserver)  

        if not lbvserver:
           return None

        if len(lbvserver.keys()) <= 1:
            """ There is no field to update on the lbvserver, so no need for an update task """
            return None

        task = {}
        task["type"] = "lbvserver"
        task["name"] = lbvserver_name
        task["operation"] = "UPDATE"
        task["state"] = lbvserver

        return task


    def _get_netscaler_renameloadbalancer_task(self, loadBalancerId, newLoadBalancerId, loadBalancer):

        if not all([loadBalancerId, newLoadBalancerId, loadBalancer]) or not "name" in loadBalancer:
            raise ImplementationError("programming error")


        existing_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId)
        new_name =  NitroUtils.get_lbvservername_from_loadbalancerid(newLoadBalancerId)


        task = {}
        task["name"] = existing_name
        task["type"] = "lbvserver"
        task["operation"] = "RENAME"
                
        obj = {}
        obj["name"] = existing_name
        obj["newname"] = new_name

        task["state"] = obj
   
        return task



    def _get_netscaler_updatenode_protocol_task(self, loadBalancerId, loadBalancer, node, newLoadBalancerId):

        servicename = NitroUtils.get_servicename_from_nodeid(loadBalancerId, node.id)

        if not "protocol" in loadBalancer:
            return None
 
        lbprotocol = loadBalancer.protocol

        servicetype = NitroUtils.get_servicetype_from_protocol(lbprotocol)
        servicetype = NitroUtils.get_decrypted_version_of_servicetype(servicetype)

        service = {}
        service["name"] = servicename                        
        service["protocol"] = servicetype

        task = {} 
        task["name"] = servicename     
        task["type"] = "service"
        task["operation"] = "UPDATE"
        task["state"] = service

        return task



    def _get_netscaler_updatenode_weight_tasks(self, loadBalancerId, loadBalancer, node, newLoadBalancerId):

        if not "algorithm" in loadBalancer:
            return None

        if loadBalancer.algorithm.startswith("WEIGHTED_"):
            return None

        newnode = self.lbresource.GetLBNode().GetStateObject()
        newnode.id = node.id
        newnode.weight = 1

        task_list = []

        task = self.nodeadapter.get_netscaler_removeservicebinding_task(loadBalancerId, loadBalancer, node.id)
        task_list.append(task)

        if newLoadBalancerId:
            task = self.nodeadapter.get_netscaler_addservicebinding_task(newLoadBalancerId, loadBalancer, node.id, newnode)
        else:
            task = self.nodeadapter.get_netscaler_addservicebinding_task(loadBalancerId, loadBalancer, node.id, newnode)

        task_list.append(task)
 
        return task_list



    def _get_netscaler_updatenode_tasks(self, loadBalancerId, loadBalancer, node, newLoadBalancerId):

        self.logger.debug("Creating update tasks for node %s" % node.id)

        task_list = [] 
        task = self._get_netscaler_updatenode_protocol_task(loadBalancerId, loadBalancer, node, newLoadBalancerId)

        if task: 
            task_list.append(task)

        self.logger.debug("Created an update task for node %s protocol" % node.id)
 
        tasks = self._get_netscaler_updatenode_weight_tasks(loadBalancerId, loadBalancer, node, newLoadBalancerId)

        if tasks: 
            task_list.extend(tasks)

        self.logger.debug("Created an update task for node %s weight" % node.id)

        return task_list 
         
            


    def _get_netscaler_updatenodes_tasks(self, loadBalancerId, loadBalancer, newLoadBalancerId=None):

        task_list = []

        """ Let's check if there is a reason we need to update the services of the loadBalancer """
        """ Currently, only a change in the protocol or algorithm property of the loadBalancer requires adjusting the 
            protocol(servicetype) property of the services """

        if not "protocol" in loadBalancer and not "algorithm" in loadBalancer :
            return task_list

        """servicenames = self._get_netscaler_servicenames_of_loadBalancer(loadBalancerId)"""

        nodes = self.nodeadapter._list_LBNodesInternal(loadBalancerId, loadBalancer)

        self.logger.debug("Retrieved nodes of loadbalancer")
 
        for node in nodes:
            tasks = self._get_netscaler_updatenode_tasks(loadBalancerId, loadBalancer, node, newLoadBalancerId)
            task_list.extend(tasks)

        return task_list


           
    def _get_netscaler_removeloadbalancer_task(self, loadBalancerId):

        lbvserver_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId)

        task = {}
        task["type"] = "lbvserver"
        task["name"] = lbvserver_name
        task["operation"] = "REMOVE"
        task["state"] = None

        return task



    def _get_netscaler_getnodes_tasks(self, loadBalancerId):
        
        task_list = [] 

        servicebindings_task = self.nodeadapter.get_netscaler_getservicebindings_task(loadBalancerId, None)

        if servicebindings_task: 
            task_list.append(servicebindings_task)  

        return task_list
 

    def _get_netscaler_addnodes_tasks(self, loadBalancerId, loadBalancer):

        tasks = []

        if "nodes" in loadBalancer:
            nodes = loadBalancer.nodes

            tasks = self.nodeadapter.get_netscaler_addnodes_tasks(loadBalancerId, loadBalancer, nodes)

        return tasks


    def _get_netscaler_removenodes_tasks(self, loadBalancerId, loadBalancer):
 
        node_tasks = self.nodeadapter.get_netscaler_removeboundservices_tasks(loadBalancerId, loadBalancer)

        return node_tasks


    def _get_netscaler_gethealthmonitor_tasks(self, loadBalancerId):

        task_list = self.monitoradapter.get_netscaler_gethealthmonitor_tasks(loadBalancerId, None)
           

        return task_list


    def _get_netscaler_addhealthmonitor_tasks(self, loadBalancerId, loadBalancer, newLoadBalancerId=None):

        task_list = [] 

        if not "healthMonitor" in loadBalancer:
            return task_list

        healthMonitor = loadBalancer.healthMonitor

        monitor_tasks = self.monitoradapter.get_netscaler_loadbalancer_addhealthmonitor_tasks(loadBalancerId, loadBalancer, healthMonitor)  
 
        return monitor_tasks


    def _get_netscaler_removehealthmonitor_tasks(self, loadBalancerId, loadBalancer):
 
        self.logger.debug("Getting tasks to remove health monitor from loadbalancer")

        task_list = self.monitoradapter.get_netscaler_removehealthmonitor_tasks(loadBalancerId, loadBalancer)

        self.logger.debug("task list to remove health monitor: %s" % repr(task_list))

        return task_list 
         
    def _get_netscaler_getconnectionlogging_tasks(self, loadBalancerId): 
 
        pass


    def _get_netscaler_addconnectionlogging_tasks(self, loadBalancerId, loadBalancer, newLoadBalancerId=None):

        task_list = [] 

        if not "connectionLogging" in loadBalancer:
            return task_list

        raise NotImplementedException("connectionLogging property is not currently supported for loadBalancer.")



    def _get_netscaler_updateconnectionlogging_tasks(self, loadBalancerId, loadBalancer, newLoadBalancerId=None): 

        pass



    def _get_netscaler_removeconnectionlogging_tasks(self, loadBalancerId): 

        pass


    def _get_netscaler_getconnectionthrottle_tasks(self, loadBalancerId):

        pass


    def _get_netscaler_addconnectionthrottle_tasks(self, loadBalancerId, loadBalancer, newLoadBalancerId=None):

        task_list = [] 

        if not "connectionThrottle" in loadBalancer:
            return task_list

        raise NotImplementedException("connectionThrottle property is not currently supported for loadBalancer.")


    def _get_netscaler_updateconnectionthrottle_tasks(self, loadBalancerId, loadBalancer, newLoadBalancerId=None):

        pass


    def _get_netscaler_removeconnectionthrottle_tasks(self, loadBalancerId):

        pass




    def _get_netscaler_tasks_for_get_op(self, loadBalancerId):

        task_list = []

        if not loadBalancerId:
            raise ImplementationErrorException("Programming error")
 
        task = NitroTasks.get_netscaler_getlbvserver_task(loadBalancerId)
        task_list.append(task)

        tasks = self._get_netscaler_getnodes_tasks(loadBalancerId)
        task_list.extend(tasks)

        tasks = self._get_netscaler_gethealthmonitor_tasks(loadBalancerId)

        """ We don't care if there is no healthmonitor set on the load balancer """

        if tasks:
           for task in tasks:
               task["ignore_notfound"] = True

        task_list.extend(tasks)

        """ XXX - We should get all info about the loadbalancer, e.g. connection logging, etc. """
        """ 
        logging_tasks = self._get_netscaler_getlogging_tasks(loadBalancer, lbvserver)
        task_list.extend(logging_tasks)
           
        throttle_tasks = self._get_netscaler_getthrottle_tasks(loadBalancer, lbvserver)
        task_list.extend(throttle_tasks)
        """

        return task_list



    def _get_netscaler_tasks_for_add_op(self, loadBalancerId, loadBalancer):

        task_list = []
    
        if not all([loadBalancerId, loadBalancer]):
            raise ImplementationErrorException("Programming error")

        task = self._get_netscaler_addloadbalancer_task(loadBalancerId, loadBalancer)

        task_list.append(task)
        lbvserver = task["state"]
        
        nodes_tasks = self._get_netscaler_addnodes_tasks(loadBalancerId, loadBalancer)
        task_list.extend(nodes_tasks)
 
        monitor_tasks = self._get_netscaler_addhealthmonitor_tasks(loadBalancerId, loadBalancer)
        task_list.extend(monitor_tasks)

        logging_tasks = self._get_netscaler_addconnectionlogging_tasks(loadBalancerId, loadBalancer)
        task_list.extend(logging_tasks)
           
        throttle_tasks = self._get_netscaler_addconnectionthrottle_tasks(loadBalancerId, loadBalancer)
        task_list.extend(throttle_tasks)

        return task_list



    def _get_netscaler_tasks_for_update_op(self, loadBalancerId, updatedLoadBalancer):

        self.logger.debug("Assembling required tasks for update operation")

        task_list = []
    
        if not all([loadBalancerId, updatedLoadBalancer]):
            raise ImplementationErrorException("Programming error")

        newLoadBalancerId = None

        if "name" in updatedLoadBalancer:

            existing_name = NitroUtils.get_loadBalancer_name(loadBalancerId)

            if updatedLoadBalancer.name != existing_name:
                self.logger.debug("We need to queue a name change task")
                """ Because the internal ID depends on the name, a name change results in a new ID """  
                newLoadBalancerId = NitroUtils.get_new_internal_loadBalancerId(loadBalancerId, updatedLoadBalancer)

                namechange_task = self._get_netscaler_renameloadbalancer_task(loadBalancerId, newLoadBalancerId, updatedLoadBalancer)
                task_list.append(namechange_task)


        self.logger.debug("Adding an lbvserver update task")
        task = self._get_netscaler_updateloadbalancer_task(loadBalancerId, updatedLoadBalancer, newLoadBalancerId)
        task_list.append(task)


        """ We also may need to change the services and other affected Netscaler resources """
        tasks = self._get_netscaler_updatenodes_tasks(loadBalancerId, updatedLoadBalancer, newLoadBalancerId)
        task_list.extend(tasks)

        return task_list



    def _get_netscaler_tasks_for_remove_op(self, loadBalancerId, loadBalancer):

        task_list = []

        if not loadBalancerId:
            raise ImplementationErrorException("Programming error")

        self.logger.debug("Getting all tasks to remove resources of loadbalancer")

        task = self._get_netscaler_removeloadbalancer_task(loadBalancerId)
        task_list.append(task)

        tasks = self._get_netscaler_removenodes_tasks(loadBalancerId, loadBalancer)
        task_list.extend(tasks)

        tasks = self._get_netscaler_removehealthmonitor_tasks(loadBalancerId, loadBalancer)
        task_list.extend(tasks)


        """ XXX - We should also remove other resources. """
        """ 
        logging_tasks = self._get_netscaler_removeconnectionlogging_tasks(loadBalancer, lbvserver)
        task_list.extend(logging_tasks)
           
        throttle_tasks = self._get_netscaler_removeconnectionthrottle_tasks(loadBalancer, lbvserver)
        task_list.extend(throttle_tasks)
        """


        return task_list


    def _get_netscaler_tasks(self, operation, loadBalancerId, loadBalancer=None):

        if operation == "GET":
            return self._get_netscaler_tasks_for_get_op(loadBalancerId)

        if operation == "ADD":
            return self._get_netscaler_tasks_for_add_op(loadBalancerId, loadBalancer)

        if operation == "UPDATE":
            return self._get_netscaler_tasks_for_update_op(loadBalancerId, loadBalancer)
        
        if operation == "REMOVE":
            return self._get_netscaler_tasks_for_remove_op(loadBalancerId, loadBalancer)

        """ We should never get here """ 
        raise ImplementationError("programming error")


    def _get_loadBalancer_from_results(self, results):
        return None



    def _allocate_loadBalancer_vip(self, virtualIP, tenant_id, loadBalancerId):

        if getattr(virtualIP, "type") != None:
            viptype = virtualIP.type
            virtualIP.address = self.lbservice.vippool_manager.allocate_virtualIP(viptype, tenant_id, loadBalancerId)
            self.logger.debug("VIP allocated is: %s" % virtualIP.address)
            return


        if getattr(virtualIP, "id") != None:
            vipid = virtualIP.id
            virtualIP.address = self.lbservice.vippool_manager.share_virtualIP(vipid, tenant_id, loadBalancerId)
            self.logger.debug("VIP retrieved by id is: %s" % virtualIP.address)
            return


    def _allocate_loadBalancer_vips(self, loadBalancer, tenant_id, loadBalancerId):

        if not loadBalancer.virtualIps: 
            raise BadRequestException("validation fault", "object is not valid", "No virtual IP field specified.") 
     
        if len(loadBalancer.virtualIps) > 1:  
            raise NotImplementedException("Not Implemented. " +
                                "Sorry, this loadBalancer service currently allow only for one virtual Ip per loadBalancer")       


        for virtualIP in loadBalancer.virtualIps:
            self._allocate_loadBalancer_vip(virtualIP, tenant_id, loadBalancerId)   



    def _get_LoadBalancerInternal(self, loadBalancerId):
 
        task_list = self._get_netscaler_tasks("GET", loadBalancerId)

        self.logger.debug("get task list: " + str(task_list))

        results = self.nitrowrapper.process_netscaler_task_list(task_list) 

        self.logger.debug("results from get task list: " + str(results))

        loadBalancer = self._extract_loadbalancer(results, loadBalancerId)

        loadBalancer.id = loadBalancerId

        loadBalancer.nodes = self._extract_nodes(results, loadBalancerId, loadBalancer) 

        loadBalancer.healthMonitor = self._extract_healthmonitor(results, loadBalancerId, loadBalancer)

        """ 
        " XXX - Still TODO "
        loadBalancer.connectionLogging = self._extract_connectionlogging(results, loadBalancerId, loadBalancer) 

        loadBalancer.connectionThrottle = self._extract_connectionthrottle(results, loadBalancerId, loadBalancer) 

        """

        return loadBalancer 



    def _add_LoadBalancerInternal(self, loadBalancerId, newLoadBalancer):

        task_list = self._get_netscaler_tasks("ADD", loadBalancerId, newLoadBalancer)

        self.logger.debug("add task list: " + str(task_list))

        if task_list: 
            self.nitrowrapper.process_netscaler_task_list(task_list) 



    def _update_LoadBalancerInternal(self, loadBalancerId, updatedLoadBalancer):

        task_list = self._get_netscaler_tasks("UPDATE", loadBalancerId, updatedLoadBalancer)                       
 
        self.logger.debug("update task list: " + str(task_list))
          
        if task_list: 
            self.nitrowrapper.process_netscaler_task_list(task_list) 



    def _remove_LoadBalancerInternal(self, loadBalancerId, loadBalancer):

        task_list = self._get_netscaler_tasks("REMOVE", loadBalancerId, loadBalancer)

        self.logger.debug("remove task list: " + str(task_list))

        if task_list: 
            self.nitrowrapper.process_netscaler_task_list(task_list)



    def _setup_nitrowrapper(self, tenant_id, loadBalancerId=None):

        connection = self.connmanager.get_nitro_connection(tenant_id, loadBalancerId)
        self.nitrowrapper = NitroCallsWrapper.get_nitrowrapper(connection, self.logger)

        self.monitoradapter = NitroLBHealthMonitorAdapter(self.lbresource, self.extensions_enabled)
        self.monitoradapter.nitrowrapper = self.nitrowrapper
        self.monitoradapter.usermonitor = connection.monitor_script 

        self.nodeadapter = NitroLBNodeAdapter(self.lbresource, self.extensions_enabled)
        self.nodeadapter.nitrowrapper = self.nitrowrapper
        self.nodeadapter.monitoradapter = self.monitoradapter


    def get_LoadBalancer(self, loadBalancerId, tenant_id):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        dbLoadBalancer = self._get_new_loadBalancer_object()

        dbLoadBalancer = self.db.fill_loadBalancer_object(tenant_id, loadBalancerId, dbLoadBalancer)

        if not dbLoadBalancer:
            raise ItemNotFoundException("No loadBalancer with id %s was found" % loadBalancerId)
        
        if dbLoadBalancer.status == "DELETED":
            dict_obj = dbLoadBalancer.get_as_dictionary()
            del dict_obj["protocol"]
            del dict_obj["algorithm"]

            return dbLoadBalancer 
             


        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, dbLoadBalancer)

        loadBalancer = self._get_LoadBalancerInternal(internal_loadBalancerId)

        loadBalancer.id = dbLoadBalancer.id 
        """ XXX- We should check whether the values in the DB are different from those returned from NetScaler
                 and change the DB to match what is on NetScaler (NetScaler is the authoritative source)
        """  
            
        loadBalancer.protocol = dbLoadBalancer.protocol
        loadBalancer.algorithm = dbLoadBalancer.algorithm
        loadBalancer.created = dbLoadBalancer.created
        loadBalancer.updated = dbLoadBalancer.updated

        self.db.fill_loadBalancer_vips_info(tenant_id, loadBalancer.id, loadBalancer)
             
        
        return loadBalancer



    def add_LoadBalancer(self, newLoadBalancer, tenant_id):

        self.logger.debug("adding loadbalancer %s" % repr(newLoadBalancer))

        existing_ids = self.db.get_tenant_loadBalancers(tenant_id)
        loadBalancerId = str(NitroUtils.generate_loadbalancerid(existing_ids))

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        self._allocate_loadBalancer_vips(newLoadBalancer, tenant_id, loadBalancerId)

        internalLoadBalancer = newLoadBalancer
        internalLoadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, internalLoadBalancer)

        self._add_LoadBalancerInternal(internalLoadBalancerId, internalLoadBalancer)

        loadBalancer = self._get_LoadBalancerInternal(internalLoadBalancerId)

        loadBalancer.id = loadBalancerId
        loadBalancer.protocol = internalLoadBalancer.protocol
        loadBalancer.algorithm = internalLoadBalancer.algorithm
    
        self.db.create_loadBalancer(tenant_id, loadBalancer)

        self.db.fill_loadBalancer_vips_info(tenant_id, loadBalancer.id, loadBalancer)

        return loadBalancer


    def add_LoadBalancers(self, loadBalancers, tenant_id):

        response_loadBalancers = []

        for loadBalancer in loadBalancers:
            resp_item = self.add_LoadBalancer(loadBalancer, tenant_id)
            response_loadBalancers.append(resp_item)  

        return response_loadBalancers


    def update_LoadBalancer(self, loadBalancerId, updatedLoadBalancer, tenant_id):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        dbLoadBalancer = self._get_new_loadBalancer_object()

        dbLoadBalancer = self.db.fill_loadBalancer_object(tenant_id, loadBalancerId, dbLoadBalancer)

        if not dbLoadBalancer:
            raise ItemNotFoundException("No loadBalancer with id %s was found" % loadBalancerId)
        
        if dbLoadBalancer.status == "DELETED":
            raise ImmutableEntityException("loadBalancer with id %s was deleted and cannot be updated" % loadBalancerId)
 

        internalLoadBalancer = updatedLoadBalancer

        internalLoadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, dbLoadBalancer)

        self._update_LoadBalancerInternal(internalLoadBalancerId, internalLoadBalancer)

        dbLoadBalancer = self.db.update_loadBalancer(tenant_id, loadBalancerId, internalLoadBalancer)

        internalLoadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, dbLoadBalancer)

        loadBalancer = self._get_LoadBalancerInternal(internalLoadBalancerId)

        loadBalancer.id = dbLoadBalancer.id 
        loadBalancer.protocol = dbLoadBalancer.protocol
        loadBalancer.algorithm = dbLoadBalancer.algorithm
        loadBalancer.created = dbLoadBalancer.created
        loadBalancer.updated = dbLoadBalancer.updated
 
        self.db.fill_loadBalancer_vips_info(tenant_id, loadBalancer.id, loadBalancer)

        self.logger.debug("Successfully completed update loadbalancer operation on the adapter")

        return loadBalancer


    def remove_LoadBalancer(self, loadBalancerId, tenant_id):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        loadBalancer = self.get_LoadBalancer(loadBalancerId, tenant_id)
 
        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        self._remove_LoadBalancerInternal(internal_loadBalancerId, loadBalancer)   

        self.db.remove_loadBalancer(tenant_id, loadBalancerId)

 

    def list_LoadBalancers(self, tenant_id):

        self._setup_nitrowrapper(tenant_id)

        resource_type = "lbvserver"

        loadBalancers = []

        """ First get active load-balancers """
        loadBalancerIds = self.db.get_tenant_activeloadBalancers(tenant_id)
 
        self.logger.debug("active loadBalancer list is: %s" % str(loadBalancerIds)) 

        for loadBalancerId in loadBalancerIds:
            loadBalancer = self.get_LoadBalancer(loadBalancerId, tenant_id)
            loadBalancers.append(loadBalancer)

        """ Get deleted load-balancers """
        loadBalancerIds = self.db.get_tenant_deletedloadBalancers(tenant_id)

        self.logger.debug("Deleted loadBalancer list is: %s" % str(loadBalancerIds)) 

        for loadBalancerId in loadBalancerIds:
            loadBalancer = self.get_LoadBalancer(loadBalancerId, tenant_id)
            loadBalancers.append(loadBalancer)

        return loadBalancers

