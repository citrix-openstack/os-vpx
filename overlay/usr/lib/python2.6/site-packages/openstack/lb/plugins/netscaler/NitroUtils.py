import random
import re

from openstack.common.BadRequestException import BadRequestException
from openstack.common.LoadBalancerFaultException import LoadBalancerFaultException
from openstack.common.ItemNotFoundException import ItemNotFoundException
from openstack.common.ServiceUnavailableException import ServiceUnavailableException
from openstack.common.NotImplementedException import NotImplementedException
from openstack.common.ImplementationErrorException import ImplementationErrorException

from openstack.common.RegexUtils import all_matching_strings


MAX_NODEID = 99999
MAX_LOADBALANCERID=9999
MAX_VIPID=99999

class NitroUtils(object):


    @staticmethod
    def get_lbvservername_from_loadbalancerid(loadBalancerId):

        return loadBalancerId


    @staticmethod
    def get_loadbalancerid_from_lbvservername(lbvserver_name):
        
        return lbvserver_name
  

    @staticmethod
    def get_loadbalancerids_for_tenant(tenant_id, lbvservers):

        loadBalancerIds = []
         
        for lbvserver in lbvservers:

            lbvserver_name = lbvserver["name"]

            loadBalancerId = NitroUtils.get_loadbalancerid_from_lbvservername(tenant_id, lbvserver_name)

            if loadBalancerId:
                loadBalancerIds.append(loadBalancerId)

        return loadBalancerIds
 
    @staticmethod
    def get_servicename_from_nodeid(internalLoadBalancerId, nodeid):

        tenant_id, loadBalancer_id, loadBalancer_name = NitroUtils._get_loadBalancerId_components(internalLoadBalancerId)

        service_name = "-".join([tenant_id, loadBalancer_id, str(nodeid)]) 
        
        return service_name    


    @staticmethod
    def get_monitorname_from_loadBalancerId(internalLoadBalancerId):

        tenant_id, loadBalancer_id, loadBalancer_name = NitroUtils._get_loadBalancerId_components(internalLoadBalancerId)

        monitor_name = "-".join([tenant_id, loadBalancer_id, "mon"]) 
        
        return monitor_name    


    @staticmethod
    def get_nodeid_from_servicename(loadBalancerId, servicename):

        tenant_id, loadBalancer_id, node_id = servicename.split("-")

        node_id = node_id.encode('ascii', 'ignore')

        return node_id


    @staticmethod
    def generate_id(maxid, minid=0, used_ids=None):

        if used_ids and len(used_ids) >= maxid:
            raise ImplementationErrorException("programming error")
  
        newid = random.randrange(minid, maxid)
        while newid in used_ids:
            newid = random.randrange(minid, maxid)

        return newid

   
    @staticmethod 
    def generate_nodeid(used_ids=None):
         return NitroUtils.generate_id(MAX_NODEID, 1, used_ids)
        

    @staticmethod 
    def generate_loadbalancerid(used_ids=None):
         return NitroUtils.generate_id(MAX_LOADBALANCERID, 1, used_ids)

    @staticmethod 
    def generate_vipid(used_ids=None):
         return NitroUtils.generate_id(MAX_VIPID, 1, used_ids)


    @staticmethod
    def _get_lbvserver_payload_from_dictobj(dictobj):
       
        if not "name" in dictobj.keys():
            raise BadRequestException("Validation fault", "The object is not valid", "name attribute of  loadbalancer missing")

        payload= "\"lbvserver\":{" 

        payload += "\"name\":\"" + dictobj["name"] + "\""

        if "servicetype" in dictobj.keys():
            servicetype = dictobj["servicetype"]
            payload += ","
            payload += "\"servicetype\":\"" + servicetype + "\""


        if "ipv46" in dictobj.keys():
            ipv46 = dictobj["ipv46"]       
            payload += ","
            payload += "\"ipv46\":\"" + ipv46 + "\""

        if "port" in dictobj.keys():
            port = dictobj["port"]
            payload += ","
            payload += "\"port\":\"" + str(port) + "\""
          
        if "lbmethod" in dictobj.keys():
            lbmethod = dictobj["lbmethod"]
            payload += ","
            payload += "\"lbmethod\":\"" + lbmethod + "\""

        if "sc" in dictobj.keys():
            sc = dictobj["sc"]
            payload += ","
            payload += "\"sc\":\"" + sc + "\""

        if "persistencetype" in dictobj.keys():
            persistencetype = dictobj["persistencetype"]
            payload += ","
            payload += "\"persistencetype\":\"" + persistencetype + "\""

        if "timeout" in dictobj.keys():
            timeout = dictobj["timeout"]
            payload += ","
            payload += "\"timeout\":\"" + timeout + "\""

        if "newname" in dictobj.keys():
            newname = dictobj["newname"]
            payload += ","
            payload += "\"newname\":\"" + newname + "\""


        payload += "}"
  
        return payload


    @staticmethod
    def _get_service_payload_from_dictobj(dictobj):
       
        if not "name" in dictobj.keys():
            raise ImplementationErrorException("programming error")

        payload= "\"service\":{" 

        payload += "\"name\":\"" + dictobj["name"] + "\""

        if "servicetype" in dictobj.keys():
            servicetype = dictobj["servicetype"]
            payload += ","
            payload += "\"servicetype\":\"" + servicetype + "\""


        if "ip" in dictobj.keys():
            ip = dictobj["ip"]       
            payload += ","
            payload += "\"ip\":\"" + ip + "\""

        if "port" in dictobj.keys():
            port = dictobj["port"]
            payload += ","
            payload += "\"port\":\"" + str(port) + "\""
          

        if "newname" in dictobj.keys():
            newname = dictobj["newname"]
            payload += ","
            payload += "\"newname\":\"" + newname + "\""


        payload += "}"
  
        return payload



    @staticmethod
    def _get_monitor_payload_from_dictobj(dictobj):
       
        if not "monitorname" in dictobj.keys():
            raise ImplementationErrorException("programming error")

        payload= "\"lbmonitor\":{" 

        payload += "\"monitorname\":\"" + dictobj["monitorname"] + "\""

        if "type" in dictobj.keys():
            montype = dictobj["type"]
            payload += ","
            payload += "\"type\":\"" + montype + "\""

        if "interval" in dictobj.keys():
            interval = dictobj["interval"]       
            payload += ","
            payload += "\"interval\":\"" + str(interval) + "\""

        if "resptimeout" in dictobj.keys():
            resptimeout = dictobj["resptimeout"]       
            payload += ","
            payload += "\"resptimeout\":\"" + str(resptimeout) + "\""

        if "retries" in dictobj.keys():
            retries = dictobj["retries"]       
            payload += ","
            payload += "\"retries\":\"" + str(retries) + "\""


        if "scriptname" in dictobj.keys():
            scriptname = dictobj["scriptname"]       
            payload += ","
            payload += "\"scriptname\":\"" + scriptname + "\""

        if "scriptargs" in dictobj.keys():
            scriptargs = dictobj["scriptargs"]       
            payload += ","
            payload += "\"scriptargs\":\"" + scriptargs + "\""


        payload += "}"
  
        return payload



    @staticmethod
    def _get_servicebinding_payload_from_dictobj(dictobj):
       
        if not "name" in dictobj.keys():
            raise ImplementationErrorException("programming error")

        payload= "\"lbvserver_service_binding\":{" 

        payload += "\"name\":\"" + dictobj["name"] + "\""

        if not "servicename" in dictobj.keys():
            raise ImplementationErrorException("programming error")

        servicename = dictobj["servicename"]
        payload += ","
        payload += "\"servicename\":\"" + servicename + "\""

        if "weight" in dictobj.keys():
            weight = dictobj["weight"]       
            payload += ","
            payload += "\"weight\":\"" + weight + "\""

        payload += "}"
  
        return payload


    @staticmethod
    def _get_monitorbinding_payload_from_dictobj(dictobj):
       
        if not "monitorname" in dictobj.keys():
            raise ImplementationErrorException("programming error")

        payload= "\"lbmonitor_service_binding\":{" 

        payload += "\"monitorname\":\"" + dictobj["monitorname"] + "\""

        if not "servicename" in dictobj.keys():
            raise ImplementationErrorException("programming error")

        servicename = dictobj["servicename"]
        payload += ","
        payload += "\"servicename\":\"" + servicename + "\""
        payload += "}"
  
        return payload

    @staticmethod 
    def get_entity_payload_from_dictobj(resource_type, resource_state):

        if resource_type == "lbvserver":
            return NitroUtils._get_lbvserver_payload_from_dictobj(resource_state)

        if resource_type == "service":
            return NitroUtils._get_service_payload_from_dictobj(resource_state)
       
        if resource_type == "lbvserver_service_binding":
            return NitroUtils._get_servicebinding_payload_from_dictobj(resource_state)

        if resource_type == "lbmonitor":
            return NitroUtils._get_monitor_payload_from_dictobj(resource_state)

        if resource_type == "lbmonitor_service_binding":
            return NitroUtils._get_monitorbinding_payload_from_dictobj(resource_state)


        raise NotImplementedException("Adding some entities is not supported yet through this API.")


    @staticmethod
    def get_servicetype_from_protocol(protocol):

        protocol = protocol.upper()

        if protocol == "HTTP":
            return "HTTP"

        if protocol == "HTTPS":
            return "SSL"

        if protocol == "FTP":
            return "FTP"

        if protocol == "SMTP":
            return "TCP"

        if protocol == "POP3":
            return "TCP"

        if protocol == "IMAPv4":
            return "TCP"

        if protocol == "LDAP":
            return "TCP"

        if protocol == "TCP":
            return "TCP"
  
        if protocol == "POPS":
            return "TCP-SSL"

        if protocol == "IMAPS":
            return "TCP-SSL"

        if protocol == "LDAPS":
            return "TCP-SSL"


        raise NotImplementedException("Sorry, this protocol is not implemented")

    @staticmethod
    def get_protocol_from_servicetype(servicetype):

        if servicetype == "HTTP":
            return "HTTP"

        if servicetype == "SSL":
            return "HTTPS"

        if servicetype == "TCP":
            return "TCP"

        if servicetype == "TCP-SSL":
            return "TCP-SSL"


        """ We should never get another lbmethod than the above values """
        raise ImplementationErrorException("programming error")


    @staticmethod
    def get_decrypted_version_of_servicetype(servicetype):

        if servicetype == "SSL-BRIDGE":
            return "SSL"

        if servicetype == "SSL":
            return "HTTP"

        if servicetype == "SSL-TCP":
            return "TCP"

        if servicetype == "HTTP":
            return servicetype

        if servicetype == "TCP":
            return servicetype
 
        if servicetype == "UDP":
            return servicetype

        """ not expecting anything else """  
        raise ImplementationErrorException("programming error")

 

  
    @staticmethod
    def get_lbmethod_from_algorithm(algorithm):

        if algorithm == "LEAST_CONNECTIONS":
 	    return "LEASTCONNECTION"

        if algorithm == "WEIGHTED_LEAST_CONNECTIONS":
	    return "LEASTCONNECTION"
 
        if algorithm == "ROUND_ROBIN":
	    return "ROUNDROBIN"

        if algorithm == "WEIGHTED_ROUND_ROBIN" :
	    return "ROUNDROBIN"

        if algorithm == "RANDOM":
            raise NotImplementedException("Sorry, this loadBalancer service currently doesn't implement the LB algorithm %s" % algorithm)
        

        """ We should never get another lbmethod than the above values """
        raise ImplementationErrorException("programming error")
  
    @staticmethod
    def get_algorithm_from_lbmethod(lbmethod):

        if lbmethod == "LEASTCONNECTION":
 	    return "LEAST_CONNECTIONS"

        if lbmethod == "ROUNDROBIN":
	    return "ROUND_ROBIN"
 
        """ We should never get another lbmethod than the above values """
        raise ImplementationErrorException("programming error")
  


    @staticmethod
    def get_nssureconnect_from_sureconnect(sureconnect):

        if sureconnect == "true":
            return "ON"

        if sureconnect == "false":
            return "OFF"

        """ We should never get another value than the above values """
        raise ImplementationErrorException("programming error")
  
    @staticmethod
    def get_persistencetype_from_nspersistencetype(nspersistencetype):

        nspersistencetype  = nspersistencetype.encode('ascii', 'ignore')
  
        if nspersistencetype == "COOKIEINSERT":
      	    return "HTTP_COOKIE"

        if nspersistencetype == "SOURCEIP":
       	    return "SOURCE_IP"

        if nspersistencetype == "NONE":
      	    return None


        """ We should never get another value than the above values """
        raise ImplementationErrorException("programming error")


    @staticmethod
    def get_nspersistencetype_from_persistencetype(persistencetype):

        if persistencetype == "HTTP_COOKIE":
      	    return "COOKIEINSERT"

        if persistencetype == "SOURCE_IP":
       	    return "SOURCEIP"

        """ We should never get another value than the above values """
        raise ImplementationErrorException("programming error")


    @staticmethod
    def get_condition_from_svrstate(svrstate):

        svrstate = svrstate.encode('ascii', 'ignore')

        if svrstate.find("OUT OF SERVICE") != -1:
            return "DISABLED"
        else:
            return "ENABLED"

        """ We should never get another value than the above values """
        raise ImplementationErrorException("programming error")
  

    @staticmethod
    def get_status_from_svrstate(svrstate):

        svrstate = svrstate.encode('ascii', 'ignore')

        if svrstate == "UP":
            return "UP"
        else:
            return "DOWN"

        """ We should never get another value than the above values """
        raise ImplementationErrorException("programming error")
  

    @staticmethod
    def get_nodestatus_from_svrstate(svrstate):

        svrstate = svrstate.encode('ascii', 'ignore')

        if svrstate == "UP":
            return "ONLINE"
        else:
            return "OFFLINE"

        """ We should never get another value than the above values """
        raise ImplementationErrorException("programming error")
  


    @staticmethod
    def get_state_from_condition(condition):

        return condition
  
        """ We should never get another value than the above values """
        raise ImplementationErrorException("programming error")

  

    @staticmethod
    def get_state_from_loadbalancerstatus(status):


        if status == "ACTIVE":
            return "UP"


        if status == "SUSPENDED":
            return "DOWN"

        """ We should never get another value than the above values """
        raise ImplementationErrorException("programming error")
  

    @staticmethod
    def get_loadbalancerstatus_from_state(state):


        if state == "UP":
            return "ACTIVE"


        if state == "DOWN":
            return "SUSPENDED"

        """ We should never get another value than the above values """
        raise ImplementationErrorException("programming error")
  


    @staticmethod
    def get_decrypted_version_of_servicetype(servicetype):

        if servicetype == "SSL-BRIDGE":
            return "SSL"

        if servicetype == "SSL":
            return "HTTP"

        if servicetype == "SSL-TCP":
            return "TCP"

        if servicetype == "HTTP":
            return servicetype

        if servicetype == "TCP":
            return servicetype
 
        if servicetype == "UDP":
            return servicetype

        """ not expecting anything else """  
        raise ImplementationErrorException("programming error")

 



    @staticmethod
    def get_servicenames_from_servicebindings(servicebindings):

        servicenames = []
     
        if not servicebindings:
            return servicenames

        for binding in servicebindings:
            servicename = binding["servicename"]
            servicenames.append(servicename)

        return servicenames

    @staticmethod
    def get_servicebinding_object(lbvserver_name, service_name):

        servicebinding = {}
        servicebinding["name"] = lbvserver_name
        servicebinding["servicename"] = service_name

        return servicebinding

    @staticmethod
    def get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer):

        return "-".join([tenant_id, loadBalancerId, loadBalancer.name])



    @staticmethod
    def _get_loadBalancerId_components(internal_loadBalancerId):

        components = internal_loadBalancerId.split("-")

        tenant_id = components[0]
        loadBalancer_id = components[1]
        loadBalancer_name = '-'.join(components[2:])

        return tenant_id, loadBalancer_id, loadBalancer_name  


    @staticmethod
    def get_external_loadBalancerId(internal_loadBalancerId):

        tenant_id, loadBalancer_id, loadBalancer_name = NitroUtils._get_loadBalancerId_components(internal_loadBalancerId)

        return loadBalancer_id  

    @staticmethod
    def get_new_internal_loadBalancerId(existing_loadBalancerId, newLoadBalancer):

        tenant_id, loadBalancer_id, loadBalancer_name = NitroUtils._get_loadBalancerId_components(existing_loadBalancerId)

        return NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancer_id, newLoadBalancer)


    @staticmethod
    def get_tenant_id(internal_loadBalancerId):

        components = internal_loadBalancerId.split("-")

        tenant_id = components[0]
        loadBalancer_id = components[1]
        loadBalancer_name = '-'.join(components[2:])

        return tenant_id  

    @staticmethod
    def get_loadBalancer_name(internal_loadBalancerId):

        components = internal_loadBalancerId.split("-")

        tenant_id = components[0]
        loadBalancer_id = components[1]
        loadBalancer_name = '-'.join(components[2:])

        return loadBalancer_name  



    @staticmethod
    def get_servicebinding_for_service(service, servicebindings):

        servicebinding = None  

        servicename = service["name"]

        for binding in servicebindings:
            if binding["servicename"] == servicename:
                servicebinding = binding 
                break

        return servicebinding


    @staticmethod
    def get_statuscode_rangelist_from_regex(regex_str):

        regex = re.compile(regex_str)

        statuscodes_list = []

        last_match = None

        alphabet = '0123456789'

        for r in all_matching_strings(alphabet, 3, regex): 
            try:
                statuscode = int(r)
            except:
                return None
            statuscodes_list.append(statuscode)

        if not statuscodes_list:
            return None

        statuscodes_list.sort()

        transformed_codes_list = []

        in_range = False

        previouscode = None

        for currentcode in statuscodes_list:
            if not previouscode:
                start = previouscode = currentcode
                continue

            if currentcode == previouscode + 1:
                if not in_range:
                    in_range = True
                    start = previouscode
            else:
                """ we may have formed a range that extends from start to previouscode """
                if start != previouscode:
                    rangecodes = '-'.join([str(start), str(previouscode)])
                else:
                    rangecodes = str(previouscode)
                    in_range = False
                start = currentcode
                transformed_codes_list.append(rangecodes)

            previouscode = currentcode

        if in_range and start != previouscode:
            """ we may have formed a range that extends from start to previouscode """
            rangecodes = '-'.join([str(start), str(previouscode)])
        else:
            rangecodes = str(previouscode)

        transformed_codes_list.append(rangecodes)

        return transformed_codes_list



    @staticmethod
    def is_bodyexpression_a_regex(regex_str):

           
        regex = re.compile(regex_str)

        """ all characters I can think of that could be in a response body """
        alphabet = '0123456789abcdefghijklmnopqrstuvwxyz</>\"\\\''

        first = True
       
        """ We only run through this loop twice to check whether this string 
            is a regular expression or just a simple string (one match max) """ 
        for r in all_matching_strings(alphabet, 1000000, regex):
              if first:
                 first = False

                 continue
              return True

        return False

           
            
          

