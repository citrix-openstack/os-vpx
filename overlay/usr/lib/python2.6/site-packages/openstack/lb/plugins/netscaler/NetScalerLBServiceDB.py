# Copyright (c) 2010 OpenStack, LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import os
import time
import datetime


from contextlib import contextmanager

from openstack.common.db import DatabaseConnectionError, get_db_connection


MAXIMUM_DAYS_TO_KEEP_DELETED_LOADBALANCERS = 90

class NetScalerLBServiceDB(object):

    def __init__(self, lbservice):
        
        self.lbservice = lbservice
        self.logger = lbservice.logger
        self.dir = lbservice.db_dir  


        self.db_file = os.path.join(self.dir, 'lb.db')
        self.conn = get_db_connection(self.db_file, okay_to_create=True)

        self.conn.execute('''CREATE TABLE IF NOT EXISTS loadbalancer (
                                tenant_id TEXT, lbid TEXT, name TEXT, protocol TEXT, algorithm TEXT,
                                status TEXT, created TEXT, updated TEXT, deleted TEXT, cluster TEXT)''')


        self.conn.execute('''CREATE TABLE IF NOT EXISTS vippool (
                                vipid TEXT, tenant_id TEXT, vip TEXT, viptype TEXT, vipversion TEXT)''')


        self.conn.execute('''CREATE TABLE IF NOT EXISTS vip_lb (
                                vipid TEXT, tenant_id TEXT, lbid TEXT)''')


        self.conn.commit()




    @contextmanager
    def get_conn(self):
        """
        Returns a DB API connection instance to the auth server's SQLite
        database. This is a contextmanager call to be use with the 'with'
        statement. It takes no parameters.
        """
        if not self.conn:
            # We go ahead and make another db connection even if this is a
            # reentry call; just in case we had an error that caused self.conn
            # to become None. Even if we make an extra conn, we'll only keep
            # one after the 'with' block.
            self.conn = get_db_connection(self.db_file)

        conn = self.conn

        self.conn = None

        try:
            yield conn
            conn.rollback()
            self.conn = conn

        except Exception, err:
            try:
                conn.close()
            except:
                pass

            self.conn = get_db_connection(self.db_file)

            raise err



    def get_allocated_vips(self, viptype):

        vip_list = []

        with self.get_conn() as conn:

            self.logger.debug("getting allocated vips of type: %s" % viptype)

            command =  "SELECT vip, vipid FROM vippool WHERE viptype =\'" + viptype + "\';"

            self.logger.debug("Select command for retrieving all vips of type %s is: %s" % (viptype,command))

            obj = conn.execute(command)

            rows = obj.fetchall()

            for row in rows:
                vip = {}
                vip["address"] = row[0] 
                vip["id"] = row[1]
                vip_list.append(vip)
     
        self.logger.info('SUCCESS get_allocated_vips(viptype=%s)' % repr(viptype))

        return vip_list





    def get_vip_from_id(self, vipid, tenant_id):

        with self.get_conn() as conn:

            self.logger.debug("getting vip for vipid %s for tenant %s" % (vipid, tenant_id))

            command =  "SELECT vip FROM vippool WHERE vipid =\'" + vipid + "\' and tenant_id=\'" + tenant_id + "\';"

            obj = conn.execute(command)

            row = obj.fetchone()

            if not row:
                return None

            vip = row[0] 

            return vip
     

    


    def get_loadBalancer_vips(self, tenant_id, loadBalancerId):

        vip_ids = []

        with self.get_conn() as conn:

            command =  "SELECT vipid FROM vip_lb WHERE lbid =\'" + loadBalancerId + "\' and tenant_id=\'" + tenant_id +  "\';"

            obj = conn.execute(command)

            rows = obj.fetchall()

            for row in rows:
               vip_id = row[0]
               vip_ids.append(vip_id)

        return vip_ids
   



    def get_vip_loadBalancers(self, vipid, tenant_id):

        lb_list = []

        with self.get_conn() as conn:

            command =  "SELECT lbid FROM vip_lb WHERE vipid =\'" + vipid + "\' and tenant_id=\'" + tenant_id + "\';"

            obj = conn.execute(command)

            rows = obj.fetchall()

            if not rows:
                return lb_list
  
            for row in rows:
                lb_list.append(row[0])


        return lb_list




    def get_vipinfo(self, vipid, tenant_id):

        vipinfo = {}

        with self.get_conn() as conn:

            command =  "SELECT vip, viptype, vipversion FROM vippool WHERE vipid =\'" + vipid + "\' and tenant_id=\'" + tenant_id + "\';"

            obj = conn.execute(command)

            row = obj.fetchone()

            if row:
                vipinfo["address"] = row[0]
                vipinfo["type"] = row[1]
                vipinfo["ipVersion"] = row[2]
                vipinfo["id"] = vipid

                return vipinfo

        return None


    def fill_loadBalancer_vips_info(self, tenant_id, loadBalancerId, loadBalancer):

        vip_ids = self.get_loadBalancer_vips(tenant_id, loadBalancerId)

        self.logger.debug("loadBalancer vips are: %s" % repr(vip_ids))

        vips_desc = {}

        for vipid in vip_ids:
            vipinfo = self.get_vipinfo(vipid,tenant_id)
            address = vipinfo["address"]
            vips_desc[address] = vipinfo


        for virtualIp in loadBalancer.virtualIps:
            address = virtualIp.address

            if address in vips_desc.keys():
                vipinfo = vips_desc[address]

                if vipinfo != None:
                    virtualIp.type = vipinfo["type"]
                    virtualIp.id = vipinfo["id"]
                    virtualIp.ipVersion = vipinfo["ipVersion"]
                   
        return       
            
              
    
    def share_vip(self, vipid, tenant_id, loadBalancerId):

        with self.get_conn() as conn:
            conn.execute('''INSERT INTO vip_lb
                (vipid, tenant_id, lbid)
                VALUES (?,?,?)''',
                (vipid, tenant_id, loadBalancerId))

            conn.commit()

        self.logger.info(
            'SUCCESS share_vip(loadBalancerId=%s, , vipid=%s, tenant_id=%s)' %
            (repr(loadBalancerId), repr(vipid), repr(tenant_id)))


    def allocate_vip(self, vipid, vip, viptype, vipversion, tenant_id, loadBalancerId):

        if not all((tenant_id, loadBalancerId, vipid, vip, viptype)):
            return False


        with self.get_conn() as conn:
            conn.execute('''INSERT INTO vippool
                (vipid, tenant_id, vip, viptype, vipversion)
                VALUES (?,?,?,?,?)''',
                (vipid, tenant_id, vip, viptype, vipversion))

            conn.commit()

            conn.execute('''INSERT INTO vip_lb
                (vipid, tenant_id, lbid)
                VALUES (?,?,?)''',
                (vipid, tenant_id, loadBalancerId))

            conn.commit()

        self.logger.info(
            'SUCCESS allocate_vip(loadBalancerId=%s, tenant_id=%s, vip=%s)' %
            (repr(loadBalancerId), repr(tenant_id), repr(vip)))


    def release_vip(self, vip, viptype):

        if not vip:
            return

        with self.get_conn() as conn:
            conn.execute("DELETE FROM vippool WHERE vip = ? and viptype=?", (vip, viptype))
            conn.commit()


        self.logger.info('SUCCESS release_vip(vip=%s)' % vip)




    def release_vip_by_id(self, vipid, tenant_id):

        if not vipid:
            return

        with self.get_conn() as conn:
            conn.execute("DELETE FROM vippool WHERE vipid = ? and tenant_id=?", (vipid, tenant_id))
            conn.commit()


        self.logger.info('SUCCESS release_vip(vipid=%s)' % vipid)



    def fill_loadBalancer_object(self, tenant_id, loadBalancerId, loadBalancer):
        

        self.logger.debug("Filling loadbalancer object from database: tenant_id=%s loadBalancerId=%s" % (tenant_id, loadBalancerId))
        with self.get_conn() as conn:
            row = conn.execute("SELECT name, protocol, algorithm, status, created, updated  FROM loadbalancer WHERE tenant_id=? and lbid=?", (tenant_id, loadBalancerId)).fetchone()
            if not row:
                return None

            loadBalancer.id = loadBalancerId        
            loadBalancer.name = row[0]
            loadBalancer.protocol = row[1]
            loadBalancer.algorithm = row[2]
            loadBalancer.status = row[3]
            loadBalancer.created = {}
            loadBalancer.created["time"] = row[4]
            loadBalancer.updated = {}
            loadBalancer.updated["time"] = row[5]
  
            return loadBalancer
                

    def get_tenant_loadBalancers(self, tenant_id):

        if not tenant_id:
            return False

        id_list = []

        with self.get_conn() as conn:

            self.logger.debug("getting loadbalancers of tenant: %s" % tenant_id)

            obj = conn.execute("SELECT lbid FROM loadbalancer WHERE tenant_id =\'" + tenant_id + "\'")

            rows = obj.fetchall()

            for row in rows:
                id_list.append(row[0])


        self.logger.info('SUCCESS get_tenant_loadBalancers(tenant_id=%s)' % repr(tenant_id))

        return id_list



    def get_tenant_activeloadBalancers(self, tenant_id):

        if not tenant_id:
            return False

        id_list = []

        with self.get_conn() as conn:

            self.logger.debug("getting active loadbalancers of tenant: %s" % tenant_id)

            command =  "SELECT lbid FROM loadbalancer WHERE tenant_id =\'" + tenant_id + "\'" + " and status != \'DELETED\';"

            self.logger.debug("Select command is: %s" % command)

            obj = conn.execute(command)

            rows = obj.fetchall()

            for row in rows:
                id_list.append(row[0])


        self.logger.info('SUCCESS get_tenant_loadBalancers(tenant_id=%s)' % repr(tenant_id))

        return id_list



    def get_tenant_deletedloadBalancers(self, tenant_id):

        if not tenant_id:
            return False

        id_list = []

        with self.get_conn() as conn:

            self.logger.debug("getting deleted loadbalancers of tenant: %s" % tenant_id)

            command =  "SELECT lbid, deleted FROM loadbalancer WHERE tenant_id =\'" + tenant_id + "\'" + " and status = \'DELETED\';"

            self.logger.debug("Select command is: %s" % command)

            obj = conn.execute(command)

            rows = obj.fetchall()

            for row in rows:
                lbid = row[0] 
                deleted = row[1]

                delete_time = time.strptime(deleted, "%Y-%m-%dT%H:%M:%S.000+0000")

                delete_datetime = datetime.datetime.fromtimestamp(time.mktime(delete_time))

                now_datetime = datetime.datetime.utcnow()

                days_since_delete = (now_datetime - delete_datetime).days

                if days_since_delete <= MAXIMUM_DAYS_TO_KEEP_DELETED_LOADBALANCERS:
                    id_list.append(lbid)
                else:
                    """ We remove the record from the DB """
                    self._remove_loadBalancer_from_db(tenant_id, lbid)                     


        self.logger.info('SUCCESS get_tenant_loadBalancers(tenant_id=%s)' % repr(tenant_id))

        return id_list




    def create_loadBalancer(self, tenant_id, loadBalancer):

        if not all((tenant_id, loadBalancer)):
            return False

        loadBalancer.created={}
        utcnow = datetime.datetime.utcnow()
        loadBalancer.created["time"] = str(utcnow.strftime("%Y-%m-%dT%H:%M:%S.000+0000"))


        self.logger.debug("creation of loadbBalancer named: %s" %  loadBalancer.name)

        self.logger.debug("creation time for loadbalancer is: %s" %  str(loadBalancer.created["time"]))

        loadBalancer.updated = loadBalancer.created

        with self.get_conn() as conn:
            conn.execute('''INSERT INTO loadbalancer
                (tenant_id, lbid, name, protocol, algorithm, status, created, updated, cluster)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                (tenant_id, loadBalancer.id, loadBalancer.name, loadBalancer.protocol, loadBalancer.algorithm, loadBalancer.status, loadBalancer.created["time"], loadBalancer.updated["time"], loadBalancer.cluster["name"]))

            conn.commit()

        self.logger.info(
            'SUCCESS create_loadBalancer(loadBalancerId=%s, tenant_id=%s)' %
            (repr(loadBalancer.id), repr(tenant_id)))



    def get_loadBalancer_name(self, tenant_id, loadBalancerId):

        with self.get_conn() as conn:
            row = conn.execute("SELECT name FROM loadbalancer WHERE lbid = ? and tenant_id = ?", (loadBalancerId, tenant_id)).fetchone()

            return row[0]


    def update_loadBalancer_updatetime(self, tenant_id, loadBalancerId):

        self.logger.debug("update called for (loadBalancerId=%s, tenant_id=%s)" % (loadBalancerId, tenant_id))

        if not all((tenant_id, loadBalancerId)):
            return False

        utcnow = datetime.datetime.utcnow()
        updatetime = str(utcnow.strftime("%Y-%m-%dT%H:%M:%S.000+0000"))

        sql_statement = "UPDATE loadbalancer SET updated=\'%s\' WHERE tenant_id = \'%s\' and lbid = \'%s\'" % (updatetime, tenant_id, loadBalancerId)

        with self.get_conn() as conn:

            conn.execute(sql_statement)
            conn.commit()

        return
      


    def update_loadBalancer(self, tenant_id, loadBalancerId, loadBalancer):

        self.logger.debug("update called for (loadBalancerId=%s, tenant_id=%s)" % (loadBalancerId, tenant_id))
        if not all((tenant_id, loadBalancerId, loadBalancer)):
            return False

        loadBalancer.id = loadBalancerId
        loadBalancer.updated={}
        utcnow = datetime.datetime.utcnow()
        loadBalancer.updated["time"] = str(utcnow.strftime("%Y-%m-%dT%H:%M:%S.000+0000"))

        self.logger.debug("update time for loadbalancer is: %s" %  loadBalancer.updated["time"])


        sqlset_expr_list = []
        sqlset_values_list = []        

        if "name" in loadBalancer:
            sqlset_expr_list.append("name = ?")
            sqlset_values_list.append(loadBalancer.name)

        if "protocol" in loadBalancer:
            sqlset_expr_list.append("protocol = ?")
            sqlset_values_list.append(loadBalancer.protocol)

        if "algorithm" in loadBalancer:
            sqlset_expr_list.append("algorithm = ?")
            sqlset_values_list.append(loadBalancer.algorithm)

        if "status" in loadBalancer:
            sqlset_expr_list.append("status = ?")
            sqlset_values_list.append(loadBalancer.status)


        sqlset_expr_list.append("updated = ?")
        sqlset_values_list.append(loadBalancer.updated["time"])

        sql_statement_list = []

        sql_statement_list.append("UPDATE loadbalancer SET ")

        separator = ""

        for expr in sqlset_expr_list:
            sql_statement_list.append(separator)
            sql_statement_list.append(expr)
            separator = ", "  

        sql_statement_list.append(" WHERE tenant_id = ? and lbid = ?")


        sql_statement = ''.join(sql_statement_list)
   
        sqlset_values_list.append(tenant_id)
        sqlset_values_list.append(loadBalancerId)
          
        values_tuple = tuple(sqlset_values_list)
 
        self.logger.debug("update sql statement is: %s" %  sql_statement)
        self.logger.debug("update sql statement values tuple  is: %s" %  repr(values_tuple))

        with self.get_conn() as conn:

            conn.execute(sql_statement, values_tuple)
            conn.commit()

        with self.get_conn() as conn:
            row = conn.execute("SELECT name, protocol, algorithm, created FROM loadbalancer WHERE lbid = ? and tenant_id = ?", (loadBalancerId, tenant_id)).fetchone()

            self.logger.debug("fetched row from database is: %s" % repr(row))

            loadBalancer.name = row[0]
            loadBalancer.protocol = row[1]
            loadBalancer.algorithm = row[2]
            loadBalancer.created = {}
            loadBalancer.created["time"] = row[3]   


        self.logger.info('SUCCESS update_loadBalancer(loadBalancerId=%s, tenant_id=%s)' % (repr(loadBalancerId), repr(tenant_id)))

        return loadBalancer



    def _remove_loadBalancer_from_db(self, tenant_id, loadBalancerId):

        if not all((tenant_id, loadBalancerId)):
            return

        with self.get_conn() as conn:
            conn.execute("DELETE FROM loadbalancer WHERE lbid = ? and tenant_id = ?", 
                         (loadBalancerId, tenant_id))
            conn.commit()

        self.logger.info(
            'SUCCESS _remove_loadBalancer_from_db(loadBalancerId=%s, tenant_id=%s)' %
            (repr(loadBalancerId), repr(tenant_id)))


    def remove_loadBalancer(self, tenant_id, loadBalancerId):

        if not all((tenant_id, loadBalancerId)):
            return

        utcnow = datetime.datetime.utcnow()

        deletetime = str(utcnow.strftime("%Y-%m-%dT%H:%M:%S.000+0000"))

        self.logger.debug("delete time for loadbalancer is: %s" %  deletetime)

        with self.get_conn() as conn:
            conn.execute("UPDATE loadbalancer SET status = ? , deleted = ? WHERE lbid = ? and tenant_id = ?", 
                         ('DELETED', deletetime, loadBalancerId, tenant_id))
            conn.commit()

            vip_ids = self.get_loadBalancer_vips(tenant_id, loadBalancerId)

            if vip_ids == None:
                return

            conn.execute("DELETE FROM vip_lb WHERE lbid = ? and tenant_id = ?", 
                         (loadBalancerId, tenant_id))            

            conn.commit()

            for vipid in vip_ids:
                loadBalancerIds = self.get_vip_loadBalancers(vipid, tenant_id)

                if loadBalancerIds:
                    return

                self.release_vip_by_id(vipid, tenant_id)  



        self.logger.info(
            'SUCCESS remove_loadBalancer(loadBalancerId=%s, tenant_id=%s)' %
            (repr(loadBalancerId), repr(tenant_id)))


