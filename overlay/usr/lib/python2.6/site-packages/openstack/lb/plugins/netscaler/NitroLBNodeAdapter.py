import httplib
import json
import re
import random

from openstack.common.BadRequestException import BadRequestException
from openstack.common.LoadBalancerFaultException import LoadBalancerFaultException
from openstack.common.ItemNotFoundException import ItemNotFoundException
from openstack.common.OverLimitException import OverLimitException
from openstack.common.ServiceUnavailableException import ServiceUnavailableException
from openstack.common.NotImplementedException import NotImplementedException
from openstack.common.ImplementationErrorException import ImplementationErrorException
from openstack.common.ImmutableEntityException import ImmutableEntityException

from openstack.lb.LBNodeState import LBNodeState

from openstack.lb.plugins.netscaler.NetScalerLoadBalancerState import NetScalerLoadBalancerState

from openstack.lb.plugins.netscaler.NitroCallsWrapper import NitroCallsWrapper
from openstack.lb.plugins.netscaler.NitroTasks import NitroTasks
from openstack.lb.plugins.netscaler.NitroUtils import NitroUtils

import NitroLoadBalancerAdapter
import NitroLBHealthMonitorAdapter

from openstack.lb.plugins.netscaler.NetScalerLBServiceDB import NetScalerLBServiceDB

MAX_NODES_PER_LOADBALANCER = 25

ipv4address_pattern = r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b"
ns_xml_namespace = "urn:citrix.com:loadbalancers:v1.0"

class NitroLBNodeAdapter(object):

    def __init__(self, lbresource, extensions_enabled=False):
        self.lbresource = lbresource
        self.lbservice = lbresource.lbservice 
        self.connmanager = self.lbservice.connmanager
        self.logger = self.lbservice.logger 
        self.extensions_enabled = extensions_enabled
        self.db = NetScalerLBServiceDB(self.lbservice)



    def _get_new_loadBalancer_object(self):

        return NetScalerLoadBalancerState(self.lbresource)


    def _get_netscaler_service_from_node(self, loadBalancerId, loadBalancer, nodeId, node):

        service_obj = {}
     

        for key in node:
 
            self.logger.debug("Examining key \"%s\" of node object" % key)

            if key == "_properties":
                continue

            if key == "id":
                service_obj["name"] = NitroUtils.get_servicename_from_nodeid(loadBalancerId, nodeId)
                continue

            if key == "address":
                service_obj["ip"] = node.address
                continue 
            
            if key == "port":
                service_obj["port"] = node.port
                continue                


        if loadBalancer:
            servicetype = NitroUtils.get_servicetype_from_protocol(loadBalancer.protocol)
            servicetype = NitroUtils.get_decrypted_version_of_servicetype(servicetype)
            service_obj["servicetype"] = servicetype 


        return service_obj
        


    def _get_netscaler_servicebinding_from_node(self, loadBalancerId, loadBalancer, nodeId, node):

        service_binding_obj = {}

        lbvserver_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId)
        service_name =  NitroUtils.get_servicename_from_nodeid(loadBalancerId, nodeId)

        service_binding_obj["name"] = lbvserver_name
        service_binding_obj["servicename"] = service_name


        if "weight" in node and node.weight != 1 :
            if not loadBalancer.algorithm.startswith("WEIGHTED_"):
                raise BadRequestException("validation fault", "invalid object", 
                                          "LB algorithm in use doesn't allow for weighted nodes")

            service_binding_obj["weight"] = node["weight"]

        return service_binding_obj
        

    def _get_netscaler_servicename_from_servicebinding(self, loadBalancerId, loadBalancer, binding):
    
        servicename = binding["servicename"]

        return servicename


             
    def _get_netscaler_node_from_service_and_servicebinding(self, loadBalancerId, loadBalancer, service, servicebinding):

        node = LBNodeState(self.lbresource)

        service_name = service["name"] 

        node.id = NitroUtils.get_nodeid_from_servicename(loadBalancerId, service_name)

        if "ipaddress" in service and service["ipaddress"]:
            ipaddress = service["ipaddress"]
            ipaddress = ipaddress.encode('ascii', 'ignore')
            node.address = ipaddress


        if "port" in service and service["port"]:
            port = service["port"]
            port = str(port)
            node.port = port 

                     
        if "svrstate" in service and service["svrstate"]:
            svrstate =  service["svrstate"]
            
            node.condition = NitroUtils.get_condition_from_svrstate(svrstate)
            node.status = NitroUtils.get_nodestatus_from_svrstate(svrstate)


        if "weight" in servicebinding and servicebinding["weight"]:
            weight = servicebinding["weight"]
            node.weight = str(weight)


        self.logger.debug("returned node is: %s" % node)

        return node



    def _get_netscaler_node_currentcondition(self, loadBalancerId, loadBalancer, nodeId):

        service_name = NitroUtils.get_servicename_from_nodeid(loadBalancerId, nodeId)

        service = self.nitrowrapper.get_netscaler_entity("service", service_name)

        svrstate = service["svrstate"]

        current_condition = NitroUtils.get_condition_from_svrstate(svrstate)

        return current_condition

 

    def _get_netscaler_getservice_task(self, loadBalancerId, loadBalancer, nodeId):
                                                           
        service_name = NitroUtils.get_servicename_from_nodeid(loadBalancerId, nodeId)
                                                
        task = {}
        task["type"] = "service"
        task["name"] = service_name
        task["operation"] = "GET"
        task["state"] = None

        return task


    def _get_netscaler_getservicebinding_task(self, loadBalancerId, loadBalancer, nodeId):

        self.logger.debug("loadBalancer Id is: %s" % loadBalancerId)
        self.logger.debug("node Id is: %s" % nodeId)

        lbvserver_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId) 
        service_name = NitroUtils.get_servicename_from_nodeid(loadBalancerId, nodeId)

        args = "servicename:" + service_name
                                                                                                        
        task = {}

        task["type"] = "lbvserver_service_binding"
        task["name"] = lbvserver_name + "?filter=" + args
        task["operation"] = "GET"
        task["state"] = None

        return task



    def _get_netscaler_addservice_task(self, loadBalancerId, loadBalancer, nodeId, node):

        service = self._get_netscaler_service_from_node(loadBalancerId, loadBalancer, nodeId, node)  

        task = {}
        task["type"] = "service"
        task["name"] = service["name"]
        task["operation"] = "ADD"
        task["state"] = service

        return task


    def _get_netscaler_updateservice_task(self, loadBalancerId, loadBalancer, nodeId, node):

        service = self._get_netscaler_service_from_node(loadBalancerId, loadBalancer, nodeId, node)

        if not service:
            return None


        """ For update operations, we cannot update the servicetype of a service, so we need to remove it 
            here. Earlier checks should have been made to throw an exception if the user tries to change 
            the protocol of the loadbalancer. """

        del service["servicetype"]

        if len(service.keys()) == 1:
           """ There is nothing to update on the service entity """
           return None
  

        task = {}
        task["type"] = "service"
        task["name"] = service["name"]
        task["operation"] = "UPDATE"
        task["state"] = service

        return task  


    def _get_netscaler_updateservice_tasks(self, loadBalancerId, loadBalancer, nodeId, node):   

        task_list = []

        task = self._get_netscaler_updateservice_task(loadBalancerId, loadBalancer, nodeId, node)
 
        if task:
            task_list.append(task)
 
        task = self._get_netscaler_updateservicestatus_task(loadBalancerId, loadBalancer, nodeId, node)

        if task: 
            task_list.append(task) 
        
        return task_list



    def _get_netscaler_removeservice_task(self, loadBalancerId, loadBalancer, nodeId):
                 
        servicename = NitroUtils.get_servicename_from_nodeid(loadBalancerId, nodeId)
                                                                                          
        task = {}
        task["type"] = "service"
        task["name"] = servicename
        task["operation"] = "REMOVE"
        task["state"] = None

        return task



    def _get_netscaler_removeservices_tasks(self, loadBalancerId, loadBalancer, nodeIds):
                                                           
        task_list = []

        for nodeId in nodeIds:
            task = self._get_netscaler_removeservice_task(loadBalancerId, loadBalancer, nodeId)
            task_list.append(task)
                              
        return task_list




    def get_netscaler_addservicebinding_task(self, loadBalancerId, loadBalancer, nodeId, node):

        service_binding_obj = self._get_netscaler_servicebinding_from_node(loadBalancerId, loadBalancer, nodeId, node)
                                                                                                           
        task = {}
        task["type"] = "lbvserver_service_binding"
        task["name"] = service_binding_obj["name"]
        task["state"] = service_binding_obj
        task["operation"] = "ADD"

        return task


    def _get_netscaler_addmonitorbinding_task(self, loadBalancerId, loadBalancer, node):

        if not "healthMonitor" in loadBalancer or not loadBalancer.healthMonitor:
            return None

        task = self.monitoradapter.get_netscaler_addmonitorbinding_task(loadBalancerId, node, loadBalancer.healthMonitor)

        return task


    def get_netscaler_updateservicebinding_tasks(self, loadBalancerId, loadBalancer, nodeId, node):   

        """ the only reason to update a binding is if the weight property on a node is updated """

        if not "weight" in node:
            return None

        """ In order to update an service binding, one has to remove the 
            existing one and add a new one """ 
             
        task_list = []

        task = self.get_netscaler_removeservicebinding_task(loadBalancerId, loadBalancer, nodeId)
        task_list.append(task)
 
        task = self.get_netscaler_addservicebinding_task(loadBalancerId, loadBalancer, nodeId, node)
        task_list.append(task)
 
        return task_list


    def get_netscaler_removeservicebinding_task(self, loadBalancerId, loadBalancer, nodeId):

        lbvserver_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId)
        servicename = NitroUtils.get_servicename_from_nodeid(loadBalancerId, nodeId)

        args = "servicename:" +  servicename
        args += ","
        args += "name:" + lbvserver_name

        task = {}
        task["type"] = "lbvserver_service_binding"
        task["name"] = lbvserver_name + "?args=" + args
        task["operation"] = "REMOVE"
        task["state"] = None

        return task


    def _get_netscaler_removeservicebindings_tasks(self, loadBalancerId, loadBalancer, nodeIds):
 
        task_list = []

        for nodeId in nodeIds:
            
            task = self.get_netscaler_removeservicebinding_task(loadBalancerId, loadBalancer, nodeId)
            task_list.append(task)

        return task_list 



    def _get_netscaler_addservicestatus_task(self, loadBalancerId, loadBalancer, nodeId, node):

        if not "condition" in node:
            return None

        service_name = NitroUtils.get_servicename_from_nodeid(loadBalancerId, nodeId)

        service = {}
        service["name"] = service_name

        task = {}
        task["type"] = "service"
        task["name"] = service_name
        task["state"] = service

        if node.condition == "ENABLED":
            task["operation"] = "ENABLE"
        else:
            task["operation"] = "DISABLE" 

        return task



    def _get_netscaler_updateservicestatus_task(self, loadBalancerId, loadBalancer, nodeId, node):

        if not "condition" in node:
            return None

        """ We shouldn't modify a service status if it's already in the desired state.
            This makes the logic of "undoing" an enable/disable operation easier, because we 
            can go ahead and disable/enable the service, without having to worry about cases
            like "what if we were enabling a service that was already enabled, in which case,
            we shouldn't disable it on the undo, we should leave it as it is.". This below 
            avoids processing these noop tasks
        """

        current_condition = self._get_netscaler_node_currentcondition(loadBalancerId, loadBalancer, nodeId)

        if current_condition == node.condition:
            return None

        return self._get_netscaler_addservicestatus_task(loadBalancerId, loadBalancer, nodeId, node)



    def _get_netscaler_updatenode_tasks(self, loadBalancerId, loadBalancer, nodeId, node):

        task_list = []
 
        tasks = self._get_netscaler_updateservice_tasks(loadBalancerId, loadBalancer, nodeId, node)

        if tasks:
            task_list.extend(tasks)

        tasks = self.get_netscaler_updateservicebinding_tasks(loadBalancerId, loadBalancer, nodeId, node)

        if tasks:
            task_list.extend(tasks)


        return task_list
  



    def _get_netscaler_tasks_for_list_op(self, loadBalancerId, loadBalancer):

        task_list = []

        if not loadBalancerId:
            raise ImplementationErrorException("Programming error")
 

        task = self.get_netscaler_getservicebindings_task(loadBalancerId, loadBalancer)
        task_list.append(task)

        return task_list



    def _get_netscaler_tasks_for_get_op(self, loadBalancerId, loadBalancer, nodeId):

        task_list = []

        task = self._get_netscaler_getservicebinding_task(loadBalancerId, loadBalancer, nodeId)
        task_list.append(task)

        task = self._get_netscaler_getservice_task(loadBalancerId, loadBalancer, nodeId)
        task_list.append(task)

        return task_list



    def _get_netscaler_tasks_for_addmulti_op(self, loadBalancerId, loadBalancer, nodes):

        existing_nodes = self._list_LBNodesInternal(loadBalancerId, loadBalancer)

        existing_ids = []

        for node in existing_nodes:
            existing_ids.append(node.id)

        service_tasks = self.get_netscaler_addnodes_tasks(loadBalancerId, loadBalancer, nodes, existing_ids)

        return service_tasks



    def _get_netscaler_tasks_for_add_op(self, loadBalancerId, loadBalancer, node):

        nodes = [] 
        nodes.append(node)
         
        return self._get_netscaler_tasks_for_addmulti_op(loadBalancerId, loadBalancer, nodes)



    def _get_netscaler_tasks_for_update_op(self, loadBalancerId, loadBalancer, nodeId, node):
    
        if not node:
            raise ImplementationErrorException("Programming error")

        task_list = self._get_netscaler_updatenode_tasks(loadBalancerId, loadBalancer, nodeId, node)

        return task_list


    def _get_netscaler_tasks_for_remove_op(self, loadBalancerId, loadBalancer, nodeId):

        task_list = []

        if not all([loadBalancerId, loadBalancer, nodeId]):
            raise ImplementationErrorException("Programming error")
  
        task = self.get_netscaler_removeservicebinding_task(loadBalancerId, loadBalancer, nodeId)
        task_list.append(task)
 
        task = self._get_netscaler_removeservice_task(loadBalancerId, loadBalancer, nodeId)
        task_list.append(task)

        return task_list



    def _get_netscaler_tasks(self, operation, loadBalancerId, loadBalancer, nodeId=None, node=None):

        if operation == "LIST":
            return self._get_netscaler_tasks_for_list_op(loadBalancerId, loadBalancer)

        if operation == "GET":
            return self._get_netscaler_tasks_for_get_op(loadBalancerId, loadBalancer, nodeId)

        if operation == "ADD":
            return self._get_netscaler_tasks_for_add_op(loadBalancerId, loadBalancer, node)

        if operation == "ADDMULTI":
            nodes = node
            return self._get_netscaler_tasks_for_addmulti_op(loadBalancerId, loadBalancer, nodes)

        if operation == "UPDATE":
            return self._get_netscaler_tasks_for_update_op(loadBalancerId, loadBalancer, nodeId, node)
        
        if operation == "REMOVE":
            return self._get_netscaler_tasks_for_remove_op(loadBalancerId, loadBalancer, nodeId)

        """ We should never get here """ 
        raise ImplementationError("programming error")
   

 
    def _build_lbnodes(self, loadBalancerId, loadBalancer, services, servicebindings):
        
        nodes = self.get_netscaler_nodes_from_services_and_servicebindings(loadBalancerId, loadBalancer, services, servicebindings)

        self.logger.debug("nodes of loadBalancer are: %s" % str(nodes))
 
        return nodes


    def _build_lbnode(self, loadBalancerId, loadBalancer, nodeId, service, servicebinding):


        node = self._get_netscaler_node_from_service_and_servicebinding(loadBalancerId, loadBalancer, service, servicebinding)

        if node.id != nodeId:
            raise ImplementationError("programming error")

        self.logger.debug("node %s has the following state: %s" % (nodeId, str(node)))
 
        return node


    def get_netscaler_nodes_from_services_and_servicebindings(self, loadBalancerId, loadBalancer, services, servicebindings):

        nodes = []

        if not services:
            return nodes

        for service in services:
            servicebinding = NitroUtils.get_servicebinding_for_service(service, servicebindings)

            if servicebinding:
                node = self._get_netscaler_node_from_service_and_servicebinding(loadBalancerId, loadBalancer, service, servicebinding)
                nodes.append(node)

        if not nodes:
            return None

        return nodes 
       


    def get_netscaler_addnodes_tasks(self, loadBalancerId, loadBalancer, nodes, existing_ids=[]):


        """ 
        Preconditions: 
                  A. The lbvserver object must have the following attributes
                     for this method to work:
                         1. name 
                         2. service_type

                  B. The lb_algorithm must contain a non empty value
        """
                        

        total_nodes = len(existing_ids) + len(nodes)

        self.logger.debug("existing node ids are: %s" % str(existing_ids))

        if total_nodes > MAX_NODES_PER_LOADBALANCER:
            raise OverLimitException("Number of nodes exceeds maximum of %s allowed per load balancer" % MAX_NODES_PER_LOADBALANCER)
 
        task_list = []

        for node in nodes:

            if not "id" in node:
                operation = "ADD"
                nodeid = NitroUtils.generate_nodeid(existing_ids)
                existing_ids.append(nodeid) 
                node.id = str(nodeid)

            else:
                operation = "UPDATE"

            task = self._get_netscaler_addservice_task(loadBalancerId, loadBalancer, node.id, node)
            task["operation"] = operation
            task_list.append(task)    
              
            task = self.get_netscaler_addservicebinding_task(loadBalancerId, loadBalancer, node.id, node)
            task_list.append(task)

            service_name = NitroUtils.get_servicename_from_nodeid(loadBalancerId, node.id)

            if operation == "ADD": 
                task = self._get_netscaler_addservicestatus_task(loadBalancerId, loadBalancer, node.id, node)
                task = self._get_netscaler_addmonitorbinding_task(loadBalancerId, loadBalancer, node)

            if operation == "UPDATE":
                task = self._get_netscaler_updateservicestatus_task(loadBalancerId, loadBalancer, node.id, node)

            if task:
                task_list.append(task) 
        

        return task_list  



    def get_netscaler_removeboundservices_tasks(self, loadBalancerId, loadBalancer):

       """I need first to get the list of service names"""

       task_list = []

       task = self.get_netscaler_getservicebindings_task(loadBalancerId, loadBalancer) 
       task_list.append(task)  

       completed_tasks = self.nitrowrapper.process_netscaler_task_list(task_list)

       servicebindings = NitroTasks.extract_servicebindings_from_task_list(completed_tasks)

       if not servicebindings:
           return task_list

       """ We form a new task list to remove the service bindings and the services """

       nodeIds = []

       for binding in servicebindings:
           servicename = self._get_netscaler_servicename_from_servicebinding(loadBalancerId, loadBalancer, binding) 
           nodeId = NitroUtils.get_nodeid_from_servicename(loadBalancerId, servicename)
           nodeIds.append(nodeId)

 
       task_list = []

       tasks = self._get_netscaler_removeservicebindings_tasks(loadBalancerId, loadBalancer, nodeIds)
       task_list.extend(tasks)

       tasks = self._get_netscaler_removeservices_tasks(loadBalancerId, loadBalancer, nodeIds)
       task_list.extend(tasks)
 
       return task_list



    def get_netscaler_getservices_tasks(self, loadBalancerId, loadBalancer, servicebindings):
                                                           
        task_list = []

        for binding in servicebindings:
            servicename = binding["servicename"]
            nodeId = NitroUtils.get_nodeid_from_servicename(loadBalancerId, servicename)
            task = self._get_netscaler_getservice_task(loadBalancerId, loadBalancer, nodeId)
            task_list.append(task)
                              
        return task_list


    def get_netscaler_getservicebindings_task(self, loadBalancerId, loadBalancer):
                 
        lbvserver_name = NitroUtils.get_lbvservername_from_loadbalancerid(loadBalancerId)
                                                                                          
        task = {}
        task["type"] = "lbvserver_service_binding"
        task["name"] = lbvserver_name
        task["operation"] = "GET"
        task["state"] = None

        return task


    def _setup_nitrowrapper(self, tenant_id, loadBalancerId=None):

        connection = self.connmanager.get_nitro_connection(tenant_id, loadBalancerId)

        self.nitrowrapper = NitroCallsWrapper.get_nitrowrapper(connection, self.logger)

        self.lbadapter = NitroLoadBalancerAdapter.NitroLoadBalancerAdapter(self.lbresource, self.extensions_enabled)
        self.monitoradapter = NitroLBHealthMonitorAdapter.NitroLBHealthMonitorAdapter(self.lbresource, self.extensions_enabled)

    def _list_LBNodesInternal(self, loadBalancerId, loadBalancer):

        task_list = self._get_netscaler_tasks("LIST", loadBalancerId, loadBalancer)

        self.logger.debug("LIST nodes tasklist: " + str(task_list))

        results = self.nitrowrapper.process_netscaler_task_list(task_list) 

        servicebindings = NitroTasks.extract_servicebindings_from_task_list(results)
 
        if servicebindings:
            task_list = self.get_netscaler_getservices_tasks(loadBalancerId, loadBalancer, servicebindings)

            results = self.nitrowrapper.process_netscaler_task_list(task_list) 

            services = NitroTasks.extract_services_from_task_list(results, servicebindings)
        else:
            services = None

        lbnodes = self._build_lbnodes(loadBalancerId, loadBalancer, services, servicebindings)

        return lbnodes 


    def _get_LBNodeInternal(self, loadBalancerId, loadBalancer, nodeId):

        task_list = self._get_netscaler_tasks("GET", loadBalancerId, loadBalancer, nodeId)

        self.logger.debug("GET nodes tasklist: " + str(task_list))

        results = self.nitrowrapper.process_netscaler_task_list(task_list) 

        servicebindings = NitroTasks.extract_servicebindings_from_task_list(results)        

        """ we are expecting only one binding back """
        if not servicebindings or len(servicebindings) != 1:
            self.logger.debug("servicebindings list returned: %s " % str(servicebindings))
            raise ImplementationErrorException("programming error ")

        servicebinding = servicebindings[0]  

        self.logger.debug("servicebinding retrieved: " + str(servicebinding))

        service = NitroTasks.extract_service_from_task_list(results, servicebinding) 

        lbnode = self._build_lbnode(loadBalancerId, loadBalancer, nodeId, service, servicebinding)

        return lbnode


    def _update_LBNodeInternal(self, loadBalancerId, loadBalancer, nodeId, node):

        task_list = self._get_netscaler_tasks("UPDATE", loadBalancerId, loadBalancer, nodeId, node)
                                                    
        remove_task = None
            
        for task in task_list:
            resource_name = task["name"]
            resource_type = task["type"]
            resource_state = task["state"]

            if resource_type == "service" and task["operation"] == "UPDATE":
                """ If there is no field to update in this UPDATE operation, then there
                    is no point of dispatching a useless update task"""
                if len(resource_state.keys()) <= 1:
                    remove_task = task

                break                      


        if remove_task:
           task_list.remove(remove_task)                                                                                  
        
        self.logger.debug("update task list: " + str(task_list))
          
        if task_list: 
            self.nitrowrapper.process_netscaler_task_list(task_list) 

        return self._get_LBNodeInternal(loadBalancerId, loadBalancer, nodeId)



    def _remove_LBNodeInternal(self, loadBalancerId, loadBalancer, nodeId):

        task_list = self._get_netscaler_tasks("REMOVE", loadBalancerId, loadBalancer, nodeId)

        self.logger.debug("remove task list: " + str(task_list))

        self.nitrowrapper.process_netscaler_task_list(task_list)


    def list_LBNodes(self, tenant_id, loadBalancerId):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        loadBalancer = self.lbadapter.get_LoadBalancer(loadBalancerId, tenant_id)

        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        return self._list_LBNodesInternal(internal_loadBalancerId, loadBalancer)



    def get_LBNode(self, tenant_id, loadBalancerId, nodeId):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        loadBalancer = self.lbadapter.get_LoadBalancer(loadBalancerId, tenant_id)

        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        lbnode = self._get_LBNodeInternal(internal_loadBalancerId, loadBalancer, nodeId)

        return lbnode 



    def add_LBNode(self, lbnode, tenant_id, loadBalancerId):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        loadBalancer = self.lbadapter.get_LoadBalancer(loadBalancerId, tenant_id)


        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        task_list = self._get_netscaler_tasks("ADD", internal_loadBalancerId, loadBalancer, node=lbnode)
        
        self.logger.debug("add task list: " + str(task_list))

        self.nitrowrapper.process_netscaler_task_list(task_list) 

        added_node = self.get_LBNode(tenant_id, loadBalancerId, lbnode.id)

        self.db.update_loadBalancer_updatetime(tenant_id, loadBalancerId)

        return added_node



    def add_LBNodes(self, lbnodes, tenant_id, loadBalancerId):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        self.logger.debug("Adding nodes to loadbalancer %s" % loadBalancerId)

        loadBalancer = self.lbadapter.get_LoadBalancer(loadBalancerId, tenant_id)

        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        task_list = self._get_netscaler_tasks("ADDMULTI", internal_loadBalancerId, loadBalancer, node=lbnodes)

        self.nitrowrapper.process_netscaler_task_list(task_list) 

        added_nodes = []

        for lbnode in lbnodes:
            node = self._get_LBNodeInternal(internal_loadBalancerId, loadBalancer, lbnode.id)
            added_nodes.append(node)     

        self.db.update_loadBalancer_updatetime(tenant_id, loadBalancerId)

        return added_nodes



    def update_LBNode(self, loadBalancerId, nodeId, lbnode, tenant_id):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)


        """"
        dbLoadBalancer = self._get_new_loadBalancer_object()

        dbLoadBalancer = self.db.fill_loadBalancer_object(tenant_id, loadBalancerId, dbLoadBalancer)

        if not dbLoadBalancer:
            raise ItemNotFoundException("No loadBalancer with id %s was found" % loadBalancerId)
        
        if dbLoadBalancer.status == "DELETED":
            raise ImmutableEntityException("loadBalancer with id %s was deleted and cannot be updated" % loadBalancerId)
        """

        loadBalancer = self.lbadapter.get_LoadBalancer(loadBalancerId, tenant_id)


        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        lbnode.id = nodeId
 
        lbnode = self._update_LBNodeInternal(internal_loadBalancerId, loadBalancer, nodeId, lbnode)

        self.db.update_loadBalancer_updatetime(tenant_id, loadBalancerId)
 
        return lbnode
        


    def remove_LBNode(self, loadBalancerId, nodeId, tenant_id):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        loadBalancer = self.lbadapter.get_LoadBalancer(loadBalancerId, tenant_id)

        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        self._remove_LBNodeInternal(internal_loadBalancerId, loadBalancer, nodeId)

        self.db.update_loadBalancer_updatetime(tenant_id, loadBalancerId)
 
