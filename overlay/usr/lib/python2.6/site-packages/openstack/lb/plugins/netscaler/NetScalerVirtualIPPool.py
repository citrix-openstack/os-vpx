from openstack.common.IPy import IP


from openstack.common.BadRequestException import BadRequestException
from openstack.common.LoadBalancerFaultException import LoadBalancerFaultException
from openstack.common.OutOfVirtualIpsException import OutOfVirtualIpsException
from openstack.common.ServiceUnavailableException import ServiceUnavailableException

from openstack.lb.plugins.netscaler.NetScalerLBServiceDB import NetScalerLBServiceDB
from openstack.lb.plugins.netscaler.NitroUtils import NitroUtils


class NetScalerVirtualIPPool(object):


    def __init__(self, lbservice, pools_config):
        self.lbservice = lbservice
        self.logger = self.lbservice.logger
        self.vip_pools = {}
        
        """ We can prepopulate it with the known ones """
        self._configure_pool("PUBLIC", pools_config)
        self._configure_pool("SERVICENET", pools_config)
        self.db = NetScalerLBServiceDB(self.lbservice) 



   
    def _configure_pool(self, viptype, pools_config):
        
        if not pools_config:
            raise LoadBalancerFaultException("Error in configuring Virtual IPs of type %s" % viptype)

        for vip_pool in pools_config:
            if vip_pool["name"].lower() == viptype.lower(): 
                pool_config = vip_pool["config"]
                break
        else:
            raise BadRequestException("Validation fault", "The object is not valid", 
                                      "VirtualIP type specified for load balancer is not a valid type")
       
        ips_str = pool_config["ips"]
        ips = ips_str.split(",")

        ips = [ip.strip() for ip in ips]


        """ validate IP addresses and ranges found in configuration """
        for ip in ips:
           try:
                IP(ip)
           except ValueError as msg:
               self.logger.debug("Virtual IP range %s specified in configuration file is invalid:%s" % (ip, msg)) 
               raise ServiceUnavailableException("Invalid service configuration.Please contact support")

        self.vip_pools[viptype] = ips 



    def _is_range(self, vip):

       if "-" in vip or "/" in vip:
           return True

       return False
  

    def _get_next_address(self, address_str):

        next_address = IP(IP(address_str).int() + 1)

        return next_address.strNormal()
            

 

    def _get_free_vip_in_range2(self, start_address, end_address, allocated_vips):

        comps = start_address.split(".")

        if len(comps) != 4:
            raise LoadBalancerFaultException("Bad configuration for LB service. Malformed IP address")        

        address = start_address
        free_address = None

        while address != end_address:
            if address in allocated_vips: 
                address = self._get_next_address(address)
                if address == None:
                    return None
         
                continue

            return address 

        if end_address in allocated_vips:
            return None
        else:
            return end_address

         

    def _get_free_vip_in_range(self, vip_range, allocated_vips):

       try:
           make_net=0

           if "/" in vip_range:
               make_net=1
               ip_list = IP(vip_range, make_net=make_net)
           

       except ValueError:
           self.logger.debug("Virtual IP range %s specified in configuration file is invalid:" % vip_range) 
           raise ServiceUnavailableException("Invalid service configuration.Please contact support")
 


       if "-" in vip_range:
          start_address, end_address = vip_range.split('-')
       else:
          network_address = ip_list.net()
          broadcast_address = ip_list.broadcast()
          """ netmask or CIDR network notation """
          start_address = IP(network_address.int() + 1)
          end_address = IP(broadcast_address.int() - 1)

       self.logger.debug("VIP range: %s" % vip_range)
       self.logger.debug("       start address: %s" % str(start_address))
       self.logger.debug("       end address: %s" % str(end_address))
      
       address = self._get_free_vip_in_range2(str(start_address), str(end_address), allocated_vips)

       return address

    def get_virtualIP(self, vipid, tenant_id): 
        return self.db.get_vip_from_id(vipid, tenant_id)


    def get_virtualIP_type(self, vip): 
        return self.db.get_vip_type(vip)



    def allocate_virtualIP(self, viptype, tenant_id, loadBalancerId): 


        if not viptype in self.vip_pools.keys():
            self._configure_pool(viptype)

        all_vips = self.vip_pools[viptype]

        allocated_vips = self.db.get_allocated_vips(viptype)   
        allocated_addresses = [vip["address"] for vip in allocated_vips]
        allocated_vipids = [vip["id"] for vip in allocated_vips]

        for vip in all_vips:
            """ Check if this is an individual entry or a range """
            if self._is_range(vip):
                self.logger.debug("already allocated vips are: %s" % str(allocated_addresses)) 
                free_vip = self._get_free_vip_in_range(vip, allocated_addresses)
                if free_vip:
                    break

                continue
            else:
                if vip in allocated_addresses:
                    continue

                free_vip = vip
                break
        else:
            raise OutOfVirtualIpsException("Out of virtual IPs. Please contact support so they can make available more virtual IPs for use.")          

        vip_id = NitroUtils.generate_vipid(allocated_vipids)

        version = IP(free_vip).version()

        if version == 4:
            vip_version = "IPV4"
        elif version == 6:
            vip_version = "IPV6"
        else:
            self.logger.debug("Allocated IP address %s doesn't seem to be IPV4 or IPV6 !!" % free_vip)
            raise ServiceUnavailableException("Internal error.Please contact support") 

        self.db.allocate_vip(vip_id, free_vip, viptype, vip_version, tenant_id, loadBalancerId)


        self.logger.debug("Allocated VIP: address=%s ipVersion=%s  type=%s id=%s" % (free_vip, vip_version, viptype, vip_id))

        return free_vip



    def share_virtualIP(self, vipid, tenant_id, loadBalancerId): 

        """ Let's first check if an IP address with this ID exists """
        address = self.get_virtualIP(vipid, tenant_id)

        if not address:
            raise LoadBalancerFaultException("No virtual IP address with id %s could be found" % vipid)

        self.db.share_vip(vipid, tenant_id, loadBalancerId) 

        return address




    def release_virtualIP(self, ipaddress, viptype):
        self.db.release_vip(ipaddress, viptype)
