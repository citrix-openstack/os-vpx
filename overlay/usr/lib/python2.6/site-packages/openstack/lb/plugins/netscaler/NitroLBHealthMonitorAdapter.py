from openstack.common.BadRequestException import BadRequestException
from openstack.common.LoadBalancerFaultException import LoadBalancerFaultException
from openstack.common.ItemNotFoundException import ItemNotFoundException
from openstack.common.OverLimitException import OverLimitException
from openstack.common.ServiceUnavailableException import ServiceUnavailableException
from openstack.common.NotImplementedException import NotImplementedException
from openstack.common.ImplementationErrorException import ImplementationErrorException
from openstack.common.ImmutableEntityException import ImmutableEntityException

import openstack.common.RegexUtils

from openstack.lb.LBHealthMonitorState import LBHealthMonitorState

from openstack.lb.plugins.netscaler.NitroCallsWrapper import NitroCallsWrapper
from openstack.lb.plugins.netscaler.NitroTasks import NitroTasks
from openstack.lb.plugins.netscaler.NitroUtils import NitroUtils

from openstack.lb.plugins.netscaler.NetScalerLBServiceDB import NetScalerLBServiceDB

import NitroLoadBalancerAdapter

class NitroLBHealthMonitorAdapter(object):

    def __init__(self, lbresource, extensions_enabled=False):
        self.lbresource = lbresource
        self.lbservice = lbresource.lbservice 
        self.connmanager = self.lbservice.connmanager
        self.logger = self.lbservice.logger 
        self.extensions_enabled = extensions_enabled
        self.db = NetScalerLBServiceDB(self.lbservice)


    def get_netscaler_healthmonitor_from_monitor(self, loadBalancerId, loadBalancer, monitor):

        healthMonitor = LBHealthMonitorState(self.lbresource)

        if monitor["type"].upper() == "TCP":
            healthMonitor.type = "CONNECT"
        elif monitor["type"].upper() == "USER":
            if monitor["scriptname"] != self.usermonitor:
                self.logger.debug("Not the user script expected ! : scriptname=%s" % monitor["scriptname"])
                raise ImplementationErrorException("programming error")
        

        if "interval" in monitor and monitor["interval"]:
            delay = monitor["interval"] 
            delay = str(delay)  
            healthMonitor.delay = delay

        if "resptimeout" in monitor and monitor["resptimeout"]:
            timeout = monitor["resptimeout"] 
            timeout = str(timeout)  
            healthMonitor.timeout = timeout

        if "retries" in monitor and monitor["retries"]:
            attemptsBeforeDeactivation = monitor["retries"] 
            attemptsBeforeDeactivation = str(attemptsBeforeDeactivation)  
            healthMonitor.attemptsBeforeDeactivation = attemptsBeforeDeactivation


        if monitor["type"].upper() == "TCP":
            return healthMonitor


        if "scriptargs" in monitor and monitor["scriptargs"]:
            scriptargs = monitor["scriptargs"]
            scriptargs = scriptargs.encode('ascii', 'ignore')
            
            request_comps = scriptargs.split(';')

            if len(request_comps) < 1:
                self.logger.debug("Unexpected erroneous monitor scriptargs: %s" % repr(scriptargs)) 
                raise ImplementationErrorException("programming error")

            for comp in request_comps:

                comp_name, comp_value = comp.split('=')
                comp_value = comp_value.strip('\'')

                if comp_name == 'type':
                    healthMonitor.type = comp_value
                    continue

                if comp_name == 'path':
                    healthMonitor.path = comp_value
                    continue

                if comp_name == 'statusRegex':
                    healthMonitor.statusRegex = comp_value
                    continue

                if comp_name == 'bodyRegex':
                    healthMonitor.bodyRegex = comp_value
                    continue

                self.logger.debug("Unexpected erroneous monitor scriptargs: %s" % repr(scriptargs)) 
                raise ImplementationErrorException("programming error")
                
        """ the path must exist in the scriptargs"""
           
        if not "path" in healthMonitor or not healthMonitor.path:
            self.logger.debug("Unexpected erroneous monitor scriptargs: %s" % repr(scriptargs)) 
            raise ImplementationErrorException("programming error")
            
     
        return healthMonitor





    def _adjust_healthmonitor_state(self, newHealthMonitor, existingHealthMonitor):

        if not "type" in newHealthMonitor and "type" in existingHealthMonitor:
            newHealthMonitor.type = existingHealthMonitor.type
  
        if not "delay" in newHealthMonitor and "delay" in existingHealthMonitor:
            newHealthMonitor.delay = existingHealthMonitor.delay

        if not "timeout" in newHealthMonitor and "timeout" in existingHealthMonitor:
            newHealthMonitor.timeout = existingHealthMonitor.timeout
         
        if (not "attemptsBeforeDeactivation" in newHealthMonitor 
            and "attemptsBeforeDeactivation" in existingHealthMonitor):
            newHealthMonitor.attemptsBeforeDeactivation = existingHealthMonitor.attemptsBeforeDeactivation


        if newHealthMonitor.type.upper() == "CONNECT":
            return

        if not existingHealthMonitor.type.upper().startswith("HTTP"):
            return

        if not "path" in newHealthMonitor and "path" in existingHealthMonitor:
            newHealthMonitor.path = existingHealthMonitor.path

        if not "statusRegex" in newHealthMonitor and "statusRegex" in existingHealthMonitor:
            newHealthMonitor.statusRegex = existingHealthMonitor.statusRegex

        if not "bodyRegex" in newHealthMonitor and "bodyRegex" in existingHealthMonitor:
            newHealthMonitor.bodyRegex = existingHealthMonitor.bodyRegex
        

        if "delay" in newHealthMonitor and "timeout" in newHealthMonitor:
            delay = int(newHealthMonitor.delay)
            timeout = int (newHealthMonitor.timeout)
 
            if delay <= timeout:
                self.logger.debug("Validation error: healthMonitor delay must be greater than timeout")
                raise BadRequestException("Validation fault", "invalid object", "healthMonitor delay attribute must have a value greater than that of timeout attribute") 
        self.logger.debug("adjusted health monitor: %s" % repr(newHealthMonitor)) 




    def get_netscaler_gethealthmonitor_tasks(self, loadBalancerId, loadBalancer):
           
        task_list = []
                                                 
        monitor_name = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 
                                                
        task = {}
        task["type"] = "lbmonitor"
        task["name"] = monitor_name
        task["operation"] = "GET"
        task["state"] = None

        task_list.append(task)

        return task_list

    def _get_netscaler_monitorbinding_from_healthmonitor(self, loadBalancerId, node, healthMonitor):

        monitor_name = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 
        service_name =  NitroUtils.get_servicename_from_nodeid(loadBalancerId, node.id)

        monitor_binding = {}   
        monitor_binding["monitorname"] = monitor_name
        monitor_binding["servicename"] = service_name

        return monitor_binding


    def _get_netscaler_loadBalancer_monitor(self, loadBalancerId, loadBalancer):

        resource_type = "lbmonitor"
        monitor = None

        monitor_name = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 

        try:
            monitor = self.nitrowrapper.get_netscaler_entity(resource_type, monitor_name)
        except ItemNotFoundException:
            return None
     
        return monitor
         
        

    def _get_netscaler_monitor_from_healthmonitor(self, loadBalancerId, loadBalancer, healthMonitor):
        
        self.logger.debug("obtaining a netscaler monitor from an OpenStack healthmonitor: %s" % str(healthMonitor)) 

        if not "type" in healthMonitor or not healthMonitor.type:
            self.logger.debug("healthMonitor type attribute missing")
            raise BadRequestException("validation fault", "invalid object", "healthMonitor type attribute missing")


        if not healthMonitor.type.upper() in ["CONNECT", "HTTP", "HTTPS"]:
            self.logger.debug("healthMonitor type attribute has an invalid value")
            raise BadRequestException("validation fault", "invalid object", "healthMonitor type attribute has an invalid value")
 



        monitor = {}

        monitor["monitorname"] = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 


        if healthMonitor.type.upper() in ["HTTP", "HTTPS"]:
            monitor["type"] = "USER"
            monitor["scriptname"] = self.usermonitor 
        else:
            monitor["type"] = "TCP"

        if "delay" in healthMonitor:
            monitor["interval"] = int(healthMonitor.delay)

        if "timeout" in healthMonitor:
            monitor["resptimeout"] = int(healthMonitor.timeout)

        if "attemptsBeforeDeactivation" in healthMonitor:
            monitor["retries"] = int(healthMonitor.attemptsBeforeDeactivation)

        if monitor["type"] == "TCP":
            return monitor

        if not "path" in healthMonitor or not healthMonitor.path:
            self.logger.debug("healthMonitor of type HTTP or HTTPS has the path attribute missing")
            raise BadRequestException("validation fault", "invalid object", "healthMonitor of type HTTP or HTTPS has the path attribute missing")

        type_expr = '='.join(["type", healthMonitor.type])
        scriptargs = type_expr

        path = '\'' + healthMonitor.path + '\''
        path_expr = '='.join(["path", path])
        scriptargs = ';'.join([scriptargs, path_expr])

        if not "statusRegex" in healthMonitor or not healthMonitor.statusRegex:
            healthMonitor.statusRegex = "[1-5]{3}"

        statusRegex = '\'' + healthMonitor.statusRegex + "\'"
        status_expr = '='.join(["statusRegex", statusRegex])
        scriptargs = ';'.join([scriptargs, status_expr])


        if not "bodyRegex" in healthMonitor or not healthMonitor.bodyRegex:
            healthMonitor.bodyRegex = ".*"

        bodyRegex = '\'' + healthMonitor.bodyRegex + "\'"
        body_expr = '='.join(["bodyRegex", bodyRegex])
        scriptargs = ';'.join([scriptargs, body_expr])


        monitor["scriptargs"] = scriptargs 


        self.logger.debug("Netscaler monitor built from healthmonitor: %s" % str(monitor)) 

        return monitor  



    def _get_netscaler_addmonitor_task(self, loadBalancerId, loadBalancer, healthMonitor):

        monitor_name = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 

        state = self._get_netscaler_monitor_from_healthmonitor(loadBalancerId, loadBalancer, healthMonitor)

        task = {}
        task["type"] = "lbmonitor"
        task["name"] = monitor_name
        task["operation"] = "ADD"
        task["state"] = state

        return task


    def _get_netscaler_removemonitor_task(self, loadBalancerId, monitor):

                 
        self.logger.debug("Building task to remove monitor")
                                                                         
        task = {}
        task["type"] = "lbmonitor"
        task["name"] = monitor["monitorname"] + "?args=" + "type:" + monitor["type"]
        task["operation"] = "REMOVE"
        task["state"] = None

        return task


    def get_netscaler_addmonitorbinding_task(self, loadBalancerId, node, healthMonitor):
 
        binding = self._get_netscaler_monitorbinding_from_healthmonitor(loadBalancerId, node, healthMonitor)
 
        task = {}
        task["type"] = "lbmonitor_service_binding"
        task["name"] = binding["monitorname"]
        task["state"] = binding
        task["operation"] = "ADD"   

        return task 


    def _get_netscaler_addmonitorbinding_tasks(self, loadBalancerId, loadBalancer, healthMonitor):

                  
        task_list = []

        if not "nodes" in loadBalancer or not loadBalancer.nodes:
            return task_list
     
        for node in loadBalancer.nodes:
            task = self.get_netscaler_addmonitorbinding_task(loadBalancerId, node, healthMonitor)
            task_list.append(task)         
                                                                                             
        return task_list


    def get_netscaler_removemonitorbinding_task(self, loadBalancerId, loadBalancer, nodeId):

        monitor_name = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 
        servicename = NitroUtils.get_servicename_from_nodeid(loadBalancerId, nodeId)

        args = "servicename:" +  servicename


        task = {}
        task["type"] = "lbmonitor_service_binding"
        task["name"] = monitor_name + "?args=" + args
        task["operation"] = "REMOVE"
        task["state"] = None

        return task




    def _get_netscaler_removemonitorbinding_tasks(self, loadBalancerId, loadBalancer):
                  
        task_list = []
    
        for node in loadBalancer.nodes:
            task = self.get_netscaler_removemonitorbinding_task(loadBalancerId, loadBalancer, node.id)
            task_list.append(task)         
                                                                                             
        return task_list


    def _get_netscaler_updatemonitor_task(self, loadBalancerId, loadBalancer, healthMonitor):
    
        monitor_name = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 

        state = self._get_netscaler_monitor_from_healthmonitor(loadBalancerId, loadBalancer, healthMonitor)
 
        if len(state.keys()) < 3:
            return None

        task = {}
        task["type"] = "lbmonitor"
        task["name"] = monitor_name
        task["operation"] = "UPDATE"
        task["state"] = state

        return task

    """ This version doesn't bind the monitor to nodes """
    def get_netscaler_loadbalancer_addhealthmonitor_tasks(self, loadBalancerId, loadBalancer, healthMonitor):

        task_list = []

        """ This loadBalancer hasn't got monitors. We need to add this """
        task = self._get_netscaler_addmonitor_task(loadBalancerId, loadBalancer, healthMonitor) 

        if task:
            task_list.append(task)


        return task_list


    def get_netscaler_addhealthmonitor_tasks(self, loadBalancerId, loadBalancer, healthMonitor):

        task_list = []

        """ This loadBalancer hasn't got monitors. We need to add this """
        task = self._get_netscaler_addmonitor_task(loadBalancerId, loadBalancer, healthMonitor) 

        if task:
            task_list.append(task)

            
        """ We also need to add tasks that bind this monitor to all existing nodes """
        if loadBalancer.nodes:
            for node in loadBalancer.nodes:
                task = self.get_netscaler_addmonitorbinding_task(loadBalancerId, node, healthMonitor)

                if task: 
                    task_list.append(task)

        return task_list



    def _get_netscaler_updatemonitor_tasks(self, loadBalancerId, loadBalancer, healthMonitor):

        task_list = []

        monitor_name = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 

        if "healthMonitor" in loadBalancer and loadBalancer.healthMonitor:
            existingType = loadBalancer.healthMonitor.type.upper()

            if "type" in healthMonitor:
                newType = healthMonitor.type.upper()
            else:
                healthMonitor.type =  loadBalancer.healthMonitor.type;
                newType = existingType
  
            if newType != existingType:
               
                """ The monitor type is different, we need to remove the existing health monitor 
                    and add a new one """

                tasks = self.get_netscaler_removehealthmonitor_tasks(loadBalancerId, loadBalancer)

                if tasks:
                    task_list.extend(tasks) 
                    self._adjust_healthmonitor_state(healthMonitor, loadBalancer.healthMonitor) 
                    tasks = self.get_netscaler_addhealthmonitor_tasks(loadBalancerId, loadBalancer, healthMonitor)

                    if tasks:
                        task_list.extend(tasks)
            else:
                self._adjust_healthmonitor_state(healthMonitor, loadBalancer.healthMonitor) 
                task = self._get_netscaler_updatemonitor_task(loadBalancerId, loadBalancer, healthMonitor)

                if task:
                    task_list.append(task) 
 

        return task_list        







    def get_netscaler_updatehealthmonitor_tasks(self, loadBalancerId, loadBalancer, healthMonitor): 

        task_list = [] 

        """ Let's first find out if there is already a monitor for this load balancer """

        monitor = self._get_netscaler_loadBalancer_monitor(loadBalancerId, loadBalancer)

        if monitor == None:
            return self.get_netscaler_addhealthmonitor_tasks(loadBalancerId, loadBalancer, healthMonitor)


        if not monitor["type"] == "TCP" and not monitor["type"] == "USER": 
            self.logger.debug("We expect only TCP or USER monitor. Found: %s" % monitor["type"])
            raise ImplementationErrorException("programming error")

        """ This loadBalancer has already got a health monitor. """                          
        tasks = self._get_netscaler_updatemonitor_tasks(loadBalancerId, loadBalancer, healthMonitor) 

        if tasks:
            task_list.extend(tasks)


        return task_list




    def get_netscaler_removehealthmonitor_tasks(self, loadBalancerId, loadBalancer):

        task_list = [] 

        """ Let's first find out if there are already monitors for this load balancer """

        monitor = self._get_netscaler_loadBalancer_monitor(loadBalancerId, loadBalancer)

        if monitor:

            if loadBalancer and loadBalancer.nodes:
                """ Tasks to remove the monitor bindings to the nodes of the load balancer """
                tasks = self._get_netscaler_removemonitorbinding_tasks(loadBalancerId, loadBalancer) 

                if tasks:
                    task_list.extend(tasks)
  
            self.logger.debug("Adding task to remove monitor")

            """ A task to remove the monitor itself now """
            task = self._get_netscaler_removemonitor_task(loadBalancerId, monitor) 

            if task:
                task_list.append(task)


        return task_list



    def _get_netscaler_tasks_for_get_op(self, loadBalancerId, loadBalancer):

        task_list = []

        tasks = self.get_netscaler_gethealthmonitor_tasks(loadBalancerId, loadBalancer)

        task_list.extend(tasks)

        return task_list


    def _validate_healthmonitor(self, loadBalancerId, loadBalancer, healthMonitor):

        if "timeout" in healthMonitor and "delay" in healthMonitor:
            delay_val = int(healthMonitor.delay)
            timeout_val = int(healthMonitor.timeout)

            if timeout_val > delay_val:
                raise LoadBalancerFaultException("health monitor timeout value must be less than delay value")


    def _get_netscaler_tasks_for_update_op(self, loadBalancerId, loadBalancer, healthMonitor):

        if not healthMonitor:
            raise ImplementationErrorException("Programming error")

        self._validate_healthmonitor(loadBalancerId, loadBalancer, healthMonitor)

        task_list = self.get_netscaler_updatehealthmonitor_tasks(loadBalancerId, loadBalancer, healthMonitor)

        return task_list


    def _get_netscaler_tasks_for_remove_op(self, loadBalancerId, loadBalancer):

        task_list = []

        if not all([loadBalancerId, loadBalancer]):
            raise ImplementationErrorException("Programming error")
  
        tasks = self.get_netscaler_removehealthmonitor_tasks(loadBalancerId, loadBalancer)
        task_list.extend(tasks)
 

        return task_list



    def _get_netscaler_tasks(self, operation, loadBalancerId, loadBalancer, healthMonitor=None):

        if operation == "GET":
            return self._get_netscaler_tasks_for_get_op(loadBalancerId, loadBalancer)

        if operation == "UPDATE":
            return self._get_netscaler_tasks_for_update_op(loadBalancerId, loadBalancer, healthMonitor)
        
        if operation == "REMOVE":
            return self._get_netscaler_tasks_for_remove_op(loadBalancerId, loadBalancer)

        """ We should never get here """ 
        raise ImplementationError("programming error")




    def _get_LBHealthMonitorInternal(self, loadBalancerId, loadBalancer):

        task_list = self._get_netscaler_tasks("GET", loadBalancerId, loadBalancer)

        self.logger.debug("GET nodes tasklist: " + str(task_list))

        results = self.nitrowrapper.process_netscaler_task_list(task_list) 

        monitor_name = NitroUtils.get_monitorname_from_loadBalancerId(loadBalancerId) 

        monitor = NitroTasks.extract_monitor_from_task_list(results, monitor_name) 

        healthMonitor = self.get_netscaler_healthmonitor_from_monitor(loadBalancerId, loadBalancer, monitor)

        return healthMonitor


    def _update_LBHealthMonitorInternal(self, loadBalancerId, loadBalancer, healthMonitor):

        task_list = self._get_netscaler_tasks("UPDATE", loadBalancerId, loadBalancer, healthMonitor)
                                                    
        self.logger.debug("update task list: " + str(task_list))
          
        if task_list: 
            self.nitrowrapper.process_netscaler_task_list(task_list) 

        return self._get_LBHealthMonitorInternal(loadBalancerId, loadBalancer)



    def _remove_LBHealthMonitorInternal(self, loadBalancerId, loadBalancer):

        task_list = self._get_netscaler_tasks("REMOVE", loadBalancerId, loadBalancer)

        self.logger.debug("remove task list: " + str(task_list))

        self.nitrowrapper.process_netscaler_task_list(task_list)


    def _setup_nitrowrapper(self, tenant_id, loadBalancerId=None):

        connection = self.connmanager.get_nitro_connection(tenant_id, loadBalancerId)
        self.usermonitor = connection.monitor_script 
        self.nitrowrapper = NitroCallsWrapper.get_nitrowrapper(connection, self.logger)
        self.lbadapter = NitroLoadBalancerAdapter.NitroLoadBalancerAdapter(self.lbresource, self.extensions_enabled)




    def get_LBHealthMonitor(self, tenant_id, loadBalancerId):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        loadBalancer = self.lbadapter.get_LoadBalancer(loadBalancerId, tenant_id)

        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        healthMonitor = self._get_LBHealthMonitorInternal(internal_loadBalancerId, loadBalancer)

        return healthMonitor 


    def update_LBHealthMonitor(self, tenant_id, loadBalancerId, healthMonitor):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        loadBalancer = self.lbadapter.get_LoadBalancer(loadBalancerId, tenant_id)

        if loadBalancer.status == "DELETED":
            raise ItemNotFoundException("loadbalancer %s not found" % loadBalancerId)

        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        healthMonitor = self._update_LBHealthMonitorInternal(internal_loadBalancerId, loadBalancer, healthMonitor)

        self.db.update_loadBalancer_updatetime(tenant_id, loadBalancerId)
 
        return healthMonitor
        

    def remove_LBHealthMonitor(self, tenant_id, loadBalancerId):

        self._setup_nitrowrapper(tenant_id, loadBalancerId)

        loadBalancer = self.lbadapter.get_LoadBalancer(loadBalancerId, tenant_id)

        internal_loadBalancerId = NitroUtils.get_internal_loadBalancerId(tenant_id, loadBalancerId, loadBalancer)

        self._remove_LBHealthMonitorInternal(internal_loadBalancerId, loadBalancer)

        self.db.update_loadBalancer_updatetime(tenant_id, loadBalancerId)
 


