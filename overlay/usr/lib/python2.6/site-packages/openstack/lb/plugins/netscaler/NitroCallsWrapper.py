import httplib
import json
import time

from webob import Request, Response

from openstack.common.BadRequestException import BadRequestException
from openstack.common.LoadBalancerFaultException import LoadBalancerFaultException
from openstack.common.ItemNotFoundException import ItemNotFoundException
from openstack.common.ServiceUnavailableException import ServiceUnavailableException
from openstack.common.NotImplementedException import NotImplementedException
from openstack.common.ImplementationErrorException import ImplementationErrorException

from openstack.lb.plugins.netscaler.NitroUtils import NitroUtils


MAX_NITRO_RETRIES = 3
"sleep time in seconds"
SLEEP_TIME_BEFORE_RETRY=2 

def incr(index):
    return index + 1

class NitroCallsWrapper(object):

    @staticmethod
    def get_nitrowrapper(connection, logger):
        
        if not hasattr(NitroCallsWrapper, "nitrowrappers"):
            NitroCallsWrapper.nitrowrappers = {}

        if not connection in NitroCallsWrapper.nitrowrappers.keys():
            NitroCallsWrapper.nitrowrappers[connection] = NitroCallsWrapper(connection, logger) 

        return NitroCallsWrapper.nitrowrappers[connection]



    def __init__(self, connection, logger):
        self.logger = logger  
        self.conn = connection
        self._initialize_listindex()
     
        if self.conn.sessionid == None:
            self.nitro_login()            


    def _netscaler_undo_changes(self, completed_tasks):

        undotask_list = []

        """ We need to start from the last change. """
        completed_tasks.reverse()  

        for task in completed_tasks:
            if not "undotask" in task.keys():
                raise ImplementationError("programming error")            

            if task["undotask"]: 
                undotask_list.append(task["undotask"])

        """ Now we will process the undo list, ignoring 
            all errors (if we cannot undo changes, we are in trouble!)
            So we do not need to worry about undoing the "undo" ops.  
        """

        self.logger.debug("List of undo tasks: " + str(undotask_list))
        try:
            self.process_netscaler_task_list(undotask_list, _undoflag=False)  
        except Exception, e:
            self.logger.error("Failed to undo changes!!!") 
            raise e 
            

    def _nitro_check_for_errors(self, response_object):
           
        if not ('errorcode' in response_object.keys()) or not('message' in response_object.keys()):
            self.logger.error("Nitro Response body doesn't contain errorcode and/or message")            
            raise ImplementationErrorException("programming error.")              

        errorcode = response_object["errorcode"]
        errormessage = response_object["message"]
 
        self.logger.debug("errorcode=%s" % errorcode)
        self.logger.debug("message=%s" % errormessage)

        if errorcode == 444:
             return "SESSION_EXPIRED"

        if errorcode == 258 or errorcode == 344:
            self.logger.debug("Netscaler entity not found: %s " % errormessage)  
            raise ItemNotFoundException("resource not found") 

        if errorcode == 273 or errorcode == 2305 or errorcode == 304:
            self.logger.debug("Netscaler entity already exists: %s" % errormessage)  
            raise BadRequestException("Logic fault", "resource already exists with these settings") 

        if errorcode == 257:
            self.logger.debug("Very likely to be the wrong session persistence setting for this lb protocol: %s" % errormessage)  
            raise BadRequestException("Logic fault", "session persistence persistenceType not compatible with protocol") 

        if errorcode == 1097:
            self.logger.debug("Invalid argument for Netscaler entity: %s" % errormessage)  
            raise BadRequestException("Validation fault", "invalid value for attribute", errormessage) 

        if errorcode == 1075:
            self.logger.debug("Invalid argument for Netscaler entity: %s" % errormessage)  
            """ chop-off the name portion of the message, so as not to reveal how we are mapping names. """
            index = errormessage.find('[')
            if index != -1:
                errormessage = errormessage[:index] 

            raise BadRequestException("Validation fault", "invalid value for attribute", errormessage) 

        if errorcode == 1110:
            self.logger.debug("Invalid IP address for Netscaler entity: %s" % errormessage)  
            raise BadRequestException("Validation fault", "invalid value for attribute", "Invalid IP address") 


        """ Catch all check """
        if errorcode != 0:
            self.logger.debug("Nitro Response error code unknown: %d" % errorcode) 
                                                                      
            raise BadRequestException("Unknown Error", "Error with request", 
                                      "This request caused an error and cannot be fulfilled.") 

        return "SUCCESS"


    def _http_get_response_body(self, method, host, port, path, headers, body):

        connection = httplib.HTTPConnection(host, port=port)
        connection.request(method, path, body=body, headers=headers)
        response = connection.getresponse()

        self.logger.debug("status=%d" % response.status)

        if response.status != 200:
            self.logger.debug("Error: HTTP status code unexpected: %s" +  response.status)
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 

        return response.read()


    def _nitro_parse_response_body(self, response_body):

        try: 
            resp_dict = json.loads(response_body)
        except TypeError:
            self.logger.error("Failed to get a valid response from Netscaler: Response body: %s" % 
                                                                                response_body)            
            raise ImplementationErrorException("Programming error")

        return resp_dict              
            







    def _nitro_perform_http_request(self, method, url, request_headers=None, request_body=None, _retries=0):
         
        if _retries == MAX_NITRO_RETRIES:
            self.logger.debug("Failed to connect to Netscaler after several retries")            
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 

        if _retries > 0:
            time.sleep(SLEEP_TIME_BEFORE_RETRY)
            

        self.logger.debug("method=%s" % method) 
        self.logger.debug("host=%s" % self.conn.host)
        self.logger.debug("port=%s" % str(self.conn.port))
        self.logger.debug("url=%s" % url)

        if request_headers:  
            self.logger.debug("headers=%s" % str(request_headers))

        if request_body:  
            self.logger.debug("body=%s" % str(request_body))

        response_body = self._http_get_response_body(method, self.conn.host, self.conn.port, url, request_headers, request_body)

        self.logger.debug("response body is: %s" % response_body)

        response_dictionary = self._nitro_parse_response_body(response_body)

        status = self._nitro_check_for_errors(response_dictionary)
        
        if status == "SESSION_EXPIRED":
            return status, None

        elif status != "SUCCESS":
            """ We should never get here """
            raise ImplementationError("programming error") 


        return "SUCCESS", response_dictionary


    def nitro_login(self):

        headers = {'Content-Type':'application/x-www-form-urlencoded'} 

        body='object={ "login":{"username":"%s","password":"%s"}}' % (self.conn.user,self.conn.password)
        
        url = self.conn.path

        status, response = self._nitro_perform_http_request('POST', url, headers, body)


        if status != "SUCCESS":
	    raise ServiceUnavailableException("The Load Balancing Service is currently unavailable. Please contact support")

        if response["sessionid"]:
            self.conn.sessionid = response["sessionid"]
        else:
            self.logger.debug("Error: Login failed! status code returned by Netscaler =%d" % repr(resp_dict['errorcode']))
	    raise ServiceUnavailableException("The Load Balancing Service is currently unavailable. Please contact support")        


    def _nitro_get_netscaler_entity(self, resource_type, resource_name, _retries=0):

        if _retries == MAX_NITRO_RETRIES:
            self.logger.debug("Failed to connect to Netscaler after several retries")            
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 

        resource_name = resource_name

        path_prefix = self.conn.path

        url = path_prefix + "/" + resource_type + "/" + resource_name

        headers = {'Cookie': "sessionid=" + self.conn.sessionid}
         
        status, response = self._nitro_perform_http_request('GET', url, headers)

        if status == "SESSION_EXPIRED":
            """ login sessionid to Netscaler expired. Relogin and retry the call""" 
            self.nitro_login()
            return self._nitro_get_netscaler_entity(resource_type, resource_name, _retries + 1)


        self.logger.debug("response: %s" % str(response))

        state = None
 
        if resource_type in response.keys():
            state = response[resource_type]
 
        self.logger.debug("response object=%s" % str(state))

        """ XXX to get around a Nitro bug, we transform the returned list to the "one" resource in it, unless it's a binding """

        if resource_type.endswith("_binding"):
            return state
        else: 
            return state[0]


    def _nitro_add_netscaler_entity(self, resource_type, resource_state, _retries=0):

        if _retries == MAX_NITRO_RETRIES:
            self.logger.debug("Failed to connect to Netscaler after several retries")            
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 

        path_prefix = self.conn.path

        url = path_prefix 

        headers = {'Content-Type':'application/x-www-form-urlencoded'}

        sessionid_part = "\"sessionid\":\"" + self.conn.sessionid + "\""

        self.logger.debug("resource_type: %s" % resource_type)
        self.logger.debug("resource_state: %s" % repr(resource_state))

        entity_part = NitroUtils.get_entity_payload_from_dictobj(resource_type, resource_state)

        body= "{" + sessionid_part + "," + entity_part + "}"
       
        body = "object=" + body
             
        status, response = self._nitro_perform_http_request('POST', url, headers, body) 

        if status == "SESSION_EXPIRED":
            """ login sessionid to Netscaler expired. Relogin and retry the call""" 
            self.nitro_login()
            return self._nitro_add_netscaler_entity(resource_type, resource_state, _retries + 1)





    def _nitro_update_netscaler_entity(self, resource_type, resource_state, _retries=0):

        if _retries == MAX_NITRO_RETRIES:
            self.logger.debug("Failed to connect to Netscaler after several retries")            
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 

        path_prefix = self.conn.path

        url = path_prefix 

        headers = {'Content-Type':'application/x-www-form-urlencoded'}

        sessionid_part = "\"sessionid\":\"" + self.conn.sessionid + "\""

        entity_part = NitroUtils.get_entity_payload_from_dictobj(resource_type, resource_state)

        body= "{" + sessionid_part + "," + entity_part + "}"

        status, response = self._nitro_perform_http_request('PUT', url, headers, body) 

        if status == "SESSION_EXPIRED":
            """ login sessionid to Netscaler expired. Relogin and retry the call""" 
            self.nitro_login()
            return self._nitro_update_netscaler_entity(resource_type, resource_state, _retries + 1)



    def _nitro_remove_netscaler_entity(self, resource_type, resource_state, _retries=0):

        if _retries == MAX_NITRO_RETRIES:
            self.logger.debug("Failed to connect to Netscaler after several retries")            
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 

        resource_name = resource_state["name"]
 
        path_prefix = self.conn.path

        url = path_prefix + "/" + resource_type + "/" + resource_name

        headers = {'Cookie': "sessionid=" + self.conn.sessionid}
        
        status, response = self._nitro_perform_http_request('DELETE', url, headers)

        if status == "SESSION_EXPIRED":
            """ login sessionid to Netscaler expired. Relogin and retry the call""" 
            self.nitro_login()
            return self._nitro_remove_netscaler_entity(resource_type, resource_state, _retries + 1)



    def _nitro_rename_netscaler_entity(self, resource_type, resource_state, _retries=0): 

        if _retries == MAX_NITRO_RETRIES:
            self.logger.debug("Failed to connect to Netscaler after several retries")            
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 

        path_prefix = self.conn.path
        url = path_prefix 

        headers = {'Content-Type':'application/x-www-form-urlencoded'}

        params_part = "\"params\":{\"action\":\"rename\"}"
  
        sessionid_part = "\"sessionid\":\"" + self.conn.sessionid + "\""

        self.logger.debug("rename task state: " + str(resource_state))
        
        entity_part = NitroUtils.get_entity_payload_from_dictobj(resource_type, resource_state)

        self.logger.debug("rename body: " + str(entity_part))

        body= "{" + params_part + "," + sessionid_part + "," + entity_part + "}"
       
        body = "object=" + body
             
        status, response = self._nitro_perform_http_request('POST', url, headers, body) 

        if status == "SESSION_EXPIRED":
            """ login sessionid to Netscaler expired. Relogin and retry the call""" 
            self.nitro_login()
            return self._nitro_rename_netscaler_entity(resource_type, resource_state, _retries + 1)


    def _nitro_enable_netscaler_entity(self, resource_type, resource_state, _retries=0): 

        if _retries == MAX_NITRO_RETRIES:
            self.logger.debug("Failed to connect to Netscaler after several retries")            
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 

        path_prefix = self.conn.path
        url = path_prefix 

        headers = {'Content-Type':'application/x-www-form-urlencoded'}

        params_part = "\"params\":{\"action\":\"enable\"}"
  
        sessionid_part = "\"sessionid\":\"" + self.conn.sessionid + "\""

        self.logger.debug("enable task state: " + str(resource_state))
        
        entity_part = NitroUtils.get_entity_payload_from_dictobj(resource_type, resource_state)

        self.logger.debug("enable body: " + str(entity_part))

        body= "{" + params_part + "," + sessionid_part + "," + entity_part + "}"
       
        body = "object=" + body
             
        status, response = self._nitro_perform_http_request('POST', url, headers, body) 

        if status == "SESSION_EXPIRED":
            """ login sessionid to Netscaler expired. Relogin and retry the call""" 
            self.nitro_login()
            return self._nitro_enable_netscaler_entity(resource_type, resource_state, _retries + 1)


    def _nitro_disable_netscaler_entity(self, resource_type, resource_state, _retries=0): 

        if _retries == MAX_NITRO_RETRIES:
            self.logger.debug("Failed to connect to Netscaler after several retries")            
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 


        path_prefix = self.conn.path
        url = path_prefix 

        headers = {'Content-Type':'application/x-www-form-urlencoded'}

        params_part = "\"params\":{\"action\":\"disable\"}"
  
        sessionid_part = "\"sessionid\":\"" + self.conn.sessionid + "\""

        self.logger.debug("disable task state: " + str(resource_state))
        
        entity_part = NitroUtils.get_entity_payload_from_dictobj(resource_type, resource_state)

        self.logger.debug("disable body: " + str(entity_part))

        body= "{" + params_part + "," + sessionid_part + "," + entity_part + "}"
       
        body = "object=" + body
             
        status, response = self._nitro_perform_http_request('POST', url, headers, body) 

        if status == "SESSION_EXPIRED":
            """ login sessionid to Netscaler expired. Relogin and retry the call""" 
            self.nitro_login()
            return self._nitro_disable_netscaler_entity(resource_type, resource_state, _retries + 1)



    def _initialize_listindex(self):

        """
           The NITRO operations are ordered as in the indexes below
        """

        self.listindex = {}
        
        index = -1
        self.listindex["GET_*"] = index  = incr(index)
        self.listindex["REMOVE_lbvserver_policy_binding"] = index  = incr(index)
        self.listindex["REMOVE_lbvserver_policylabel_binding"] = index = incr(index)
        self.listindex["REMOVE_lbvserver_service_binding"] = index = incr(index)
        self.listindex["REMOVE_service_policy_binding"] = index = incr(index)
        self.listindex["REMOVE_lbvserver"] = index = incr(index)
        self.listindex["REMOVE_lbmonitor_service_binding"] = index = incr(index)
        self.listindex["REMOVE_lbmonitor"] = index = incr(index)
        self.listindex["REMOVE_service"] = index = incr(index)
        self.listindex["REMOVE_policylabel_policy_binding"] = index = incr(index)
        self.listindex["REMOVE_policylabel"] = index = incr(index)
        self.listindex["REMOVE_policy"] = index = incr(index)
        self.listindex["REMOVE_*"] = index = incr(index)
        self.listindex["RENAME_*"] = index = incr(index)
        self.listindex["ADD_policy"] = index = incr(index)
        self.listindex["ADD_policylabel"] = index = incr(index)
        self.listindex["ADD_policylabel_policy_binding"] =index = incr(index)
        self.listindex["ADD_service"] = index = incr(index)
        self.listindex["ADD_lbmonitor"] = index = incr(index)
        self.listindex["ADD_lbmonitor_service_binding"] = index = incr(index)
        self.listindex["ADD_lbvserver"] = index = incr(index)
        self.listindex["ADD_service_policy_binding"] = index = incr(index)
        self.listindex["ADD_lbvserver_service_binding"] = index = incr(index)
        self.listindex["ADD_lbvserver_policylabel_binding"] = index = incr(index)
        self.listindex["ADD_lbvserver_policy_binding"] = index = incr(index)
        self.listindex["ADD_*"] = index = incr(index)
        self.listindex["UPDATE_*"] = index = incr(index)
        self.listindex["ENABLE_*"] = index = incr(index)
        self.listindex["DISABLE_*"] = index = incr(index)
        self.listindex["_*"] = index = incr(index)
        self.number_of_lists = index + 1

        self.logger.debug("List of operation indexes size is %d" % self.number_of_lists)


    def _get_index(self, operation, entitytype):

        operations = ["ADD", "UPDATE", "REMOVE", "RENAME", "GET", "ENABLE", "DISABLE"]
 

        if operation in operations:
            key = operation + "_" + entitytype

            if key in self.listindex.keys():
                return self.listindex[key]
            
            key = operation + "_*"

            if key in self.listindex.keys():

                return self.listindex[key]

        

        """ Should never happen """
        raise ImplementationError("programming error")
    


    def _netscaler_check_can_rename_entity(self, entitytype):

        if entitytype == "lbvserver":
            return

        if entitytype == "service":
            return

        """ XXX - TODO: We need to check all the entities that we can rename
                  and add them here
        """

        raise NotImplementedException("Sorry, renaming of some objects is currently not supported")
 


    def _reorder_task_list(self, task_list):
 
        lists = []

        for i in range(self.number_of_lists):  
            lists.append([])
        
        for task in task_list:
            idx = self._get_index(task["operation"], task["type"])
            lists[idx].append(task) 
 
        new_list = []             
         
        for i in range(self.number_of_lists):
            if lists[i]:
                new_list.extend(lists[i])
    
        return new_list


    def _get_netscaler_undoadd_task(self, addtask):

        resource_type = addtask["type"]
        resource_name = addtask["name"]

        undotask = {}
        undotask["name"] = addtask["name"]
        undotask["type"] = addtask["type"]
        undotask["operation"] = "REMOVE"
        undotask["state"] = {"name": resource_name}
 
        return undotask


    def _get_netscaler_undoupdate_task(self, updatetask):

        resource_type = updatetask["type"]
        resource_name = updatetask["name"]

        try: 
            orig_state = self.get_netscaler_entity(resource_type, resource_name)  
            """ XXX - We need to remove non-updateable fields from task["reversestate"] """
        except:
            """ We ignore errors when trying to get the state for undo operation """

        undotask = {}
        undotask["name"] = updatetask["name"]
        undotask["type"] = updatetask["type"]
        undotask["operation"] = "UPDATE"
        undotask["state"] = orig_state
 
        return undotask


    def _get_netscaler_undoremove_task(self, removetask):

        resource_type = removetask["type"]
        resource_name = removetask["name"]


        orig_state = self.get_netscaler_entity(resource_type, resource_name)
        """ XXX - We need to remove ready-only fields from task["reversestate"] """
        undotask = {}
        undotask["name"] = removetask["name"]
        undotask["type"] = removetask["type"]
        undotask["operation"] = "ADD"
        undotask["state"] = orig_state
 
        return undotask


    def _get_netscaler_undorename_task(self, renametask):

        old_state = renametask["state"]   

        new_state = {}            
        new_state["name"], new_state["newname"] = old_state["newname"], old_state["name"]

        undotask = {}
        undotask["name"] = new_state["name"]
        undotask["type"] = renametask["type"]
        undotask["operation"] = renametask["operation"]
        undotask["state"] = new_state

        return undotask
          

    def _get_netscaler_undoenable_task(self, enabletask):

        old_state = enabletask["state"]   

        new_state = old_state.copy()

        undotask = {}
        undotask["name"] = new_state["name"]
        undotask["type"] = enabletask["type"]
        
        undotask["operation"] = "DISABLE"
        undotask["state"] = new_state

        return undotask
          


    def _get_netscaler_undodisable_task(self, disabletask):

        old_state = disabletask["state"]   

        new_state = old_state.copy()

        undotask = {}
        undotask["name"] = new_state["name"]
        undotask["type"] = disabletask["type"]
        undotask["operation"] = "ENABLE"
        undotask["state"] = new_state

        return undotask
          



    def _process_netscaler_addupdate_task(self, addupdatetask, undoflag):

        operation = addupdatetask["operation"] 

        resource_type = addupdatetask["type"]
        resource_state = addupdatetask["state"]

        if operation == "ADD":
            if undoflag:
                addupdatetask["undotask"] = self._get_netscaler_undoadd_task(addupdatetask)
            self._nitro_add_netscaler_entity(resource_type, resource_state)         
            return

        if operation == "UPDATE":
            if undoflag:
                addupdatetask["undotask"] = self._get_netscaler_undoupdate_task(addupdatetask)
            self._nitro_update_netscaler_entity(resource_type, resource_state)         
            return

              
        """ If we get her, something is wrong """
        raise ImplementationError("programming error") 


    def _process_netscaler_remove_task(self, removetask, undoflag):

        resource_type = removetask["type"]
        resource_name = removetask["name"]
        resource_state = {}
        resource_state["name"] = resource_name

        if undoflag:
            removetask["undotask"] = self._get_netscaler_undoremove_task(removetask)

        self._nitro_remove_netscaler_entity(resource_type, resource_state) 



    def _process_netscaler_rename_task(self, renametask, undoflag):

        resource_type = renametask["type"]
        resource_state = renametask["state"]


        if undoflag: 
            renametask["undotask"] = self._get_netscaler_undorename_task(renametask)

        self._netscaler_check_can_rename_entity(resource_type)

        self._nitro_rename_netscaler_entity(resource_type, resource_state)


    def _process_netscaler_enable_task(self, enabletask, undoflag):

        resource_type = enabletask["type"]
        resource_state = enabletask["state"]


        if undoflag: 
            enabletask["undotask"] = self._get_netscaler_undoenable_task(enabletask)

        self._nitro_enable_netscaler_entity(resource_type, resource_state)


    def _process_netscaler_disable_task(self, disabletask, undoflag):

        resource_type = disabletask["type"]
        resource_state = disabletask["state"]


        if undoflag: 
            disabletask["undotask"] = self._get_netscaler_undodisable_task(disabletask)

        self._nitro_disable_netscaler_entity(resource_type, resource_state)


    def _process_netscaler_get_task(self, gettask):

        resource_type = gettask["type"]
        resource_name = gettask["name"]

        """ We do not undo GET tasks """
        gettask["undotask"] = None

        gettask["result"] = self._nitro_get_netscaler_entity(resource_type, resource_name)


    def process_netscaler_task(self, task, _undoflag=True):

        resource_type = task["type"]
        resource_state = task["state"]
        operation = task["operation"]

        self.logger.debug("Processing task: ")
        self.logger.debug("	task type: %s" % resource_type)
        self.logger.debug("	task operation: %s" % operation)  
        self.logger.debug("	task state: %s" % str(resource_state))  
        
        if operation == "ADD" or operation == "UPDATE":
            self._process_netscaler_addupdate_task(task, _undoflag)
            return

        if operation == "REMOVE":
           self._process_netscaler_remove_task(task, _undoflag)
           return

        if operation == "RENAME":
           self._process_netscaler_rename_task(task, _undoflag)  
           return


        if operation == "GET":
           self._process_netscaler_get_task(task)  
           return

        if operation == "ENABLE":
           self._process_netscaler_enable_task(task, _undoflag)  
           return

        if operation == "DISABLE":
           self._process_netscaler_disable_task(task, _undoflag)  
           return


        """ If we get here, something is wrong"""
        raise ImplementationError("programming error")

           


    def process_netscaler_task_list(self, task_list, _undoflag=True):

        if not task_list:
            return None

        if _undoflag:
            task_list = self._reorder_task_list(task_list)

        exception_error = None
        partial_failure = False
        completed_tasks = []

        for task in task_list:
            try:
                self.process_netscaler_task(task, _undoflag)
                completed_tasks.append(task)
               
            except BadRequestException as error:
                partial_failure = True
                exception_error = error
                break

            except ItemNotFoundException as error:  
                if not "ignore_notfound" in task or not task["ignore_notfound"] :      
                    partial_failure = True
                    exception_error = error
                    break

            except ImplementationErrorException as error:
                partial_failure = True
                exception_error = error
                break

            except NotImplementedException as error:
                partial_failure = True
                exception_error = error
                break


            except ItemNotFoundException as error:
                partial_failure = True
                exception_error = error
                break

            except ServiceUnavailableException as error:
                """ A problem with Netscaler. We cannot remedy this """  
                raise error


        if partial_failure:
            self.logger.debug("partial error occurred")
            try:
                self._netscaler_undo_changes(completed_tasks)  
            except Exception, e:
                raise ServiceUnavailableException("Catastrophic error. Cannot undo changes made !!")

            raise exception_error 
        else:
            self.logger.debug("all tasks completed successfully")
            return completed_tasks



    def get_netscaler_entity(self, resource_type, resource_name):

        if resource_type == "lbmonitor_service_binding":
            resource_type = "lbmonbindings_service_binding"
  
        result = self._nitro_get_netscaler_entity(resource_type, resource_name)
   
        return result



    def get_netscaler_entities_for_type(self, resource_type, _retries=0):
 
        if _retries == MAX_NITRO_RETRIES:
            self.logger.debug("Failed to connect to Netscaler after several retries")            
            raise ImplementationErrorException("The Load Balancing Service is misbehaving." +
                                               " Please contact support") 

        path_prefix = self.conn.path
        url = path_prefix + "/" + resource_type 
  
        headers = {'Cookie': "sessionid=" + self.conn.sessionid}
        
        status, response = self._nitro_perform_http_request('GET', url, headers)

        if status == "SESSION_EXPIRED":
            """ login sessionid to Netscaler expired. Relogin and retry the call""" 
            self.nitro_login()
            return self.get_netscaler_entities_for_type(resource_type, _retries + 1)


        """ XXX - This is to get around a NITRO bug which doesn't return 
            an empty list when there are no entities. Instead it omits
            the element completely.
        """
        if not resource_type in response:
            state_list = []
        else:
            state_list = response[resource_type]

        self.logger.debug("response object=%s" % str(state_list))
 
        return state_list
 

