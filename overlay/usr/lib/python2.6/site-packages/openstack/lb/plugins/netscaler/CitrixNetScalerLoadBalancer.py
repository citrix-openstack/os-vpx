from openstack.common.odict import odict

from openstack.common.utils import shorten_string

from openstack.common.BadRequestException import BadRequestException
from openstack.common.LoadBalancerFaultException import LoadBalancerFaultException
from openstack.common.ItemNotFoundException import ItemNotFoundException
from openstack.common.ServiceUnavailableException import ServiceUnavailableException


from openstack.lb.LoadBalancer import LoadBalancer
from openstack.lb.Utils import Utils

from openstack.lb.LBNode import LBNode
from openstack.lb.LBVirtualIP import LBVirtualIP
from openstack.lb.LBSessionPersistence import LBSessionPersistence
from openstack.lb.LBAccessList import LBAccessList
from openstack.lb.LBHealthMonitor import LBHealthMonitor
from openstack.lb.LBConnectionLogging import LBConnectionLogging
from openstack.lb.LBConnectionThrottle import LBConnectionThrottle

from openstack.lb.LoadBalancerState import LoadBalancerState

from openstack.lb.plugins.netscaler.NitroLoadBalancerAdapter import NitroLoadBalancerAdapter

from openstack.lb.plugins.netscaler.CitrixNetScalerLBNode import CitrixNetScalerLBNode
from openstack.lb.plugins.netscaler.CitrixNetScalerLBVirtualIP import CitrixNetScalerLBVirtualIP
from openstack.lb.plugins.netscaler.CitrixNetScalerLBSessionPersistence import CitrixNetScalerLBSessionPersistence
from openstack.lb.plugins.netscaler.CitrixNetScalerLBHealthMonitor import CitrixNetScalerLBHealthMonitor
from openstack.lb.plugins.netscaler.CitrixNetScalerLBConnectionLogging import CitrixNetScalerLBConnectionLogging



from openstack.lb.plugins.netscaler.NetScalerLoadBalancerState import NetScalerLoadBalancerState


class CitrixNetScalerLoadBalancer(LoadBalancer):

    def __init__(self, lbservice, lbresource=None):
        LoadBalancer.__init__(self, lbservice, lbresource) 
        self.vippool_manager = self.lbservice.vippool_manager


    def init_request_environment(self, req, env):
        LoadBalancer.init_request_environment(self, req, env)
        self.extensions_enabled = self.reqenv["extensions_enabled"]
        self.tenant_id = shorten_string(env['account'])
        self.adapter = NitroLoadBalancerAdapter(self, self.extensions_enabled)


    def GetStateObject(self):

        if self.extensions_enabled:
            return NetScalerLoadBalancerState(self.lbresource) 
        else:
            return LoadBalancerState(self.lbresource)


    def GetLBNode(self):

       if self.extensions_enabled:
           return CitrixNetScalerLBNode(lbservice=self.lbservice, lbresource=self.lbresource)
       else:
           return LBNode(lbservice=self.lbservice, lbresource=self.lbresource)


    def GetLBVirtualIP(self):

       if self.extensions_enabled:
           return CitrixNetScalerLBVirtualIP(lbservice=self.lbservice, lbresource=self.lbresource)
       else:
           return LBVirtualIP(lbservice=self.lbservice, lbresource=self.lbresource)


    def GetLBSessionPersistence(self):

       if self.extensions_enabled:
           return CitrixNetScalerLBSessionPersistence(lbservice=self.lbservice, lbresource=self.lbresource)
       else: 
           return LBSessionPersistence(lbservice=self.lbservice, lbresource=self.lbresource)


    def GetLBHealthMonitor(self):

       if self.extensions_enabled:
           return CitrixNetScalerLBHealthMonitor(lbservice=self.lbservice, lbresource=self.lbresource)
       else: 
           return LBHealthMonitor(lbservice=self.lbservice, lbresource=self.lbresource)


    def GetLBConnectionLogging(self):
       if self.extensions_enabled:
           return CitrixNetScalerLBConnectionLogging(lbservice=self.lbservice, lbresource=self.lbresource)
       else: 
           return LBConnectionLogging(lbservice=self.lbservice, lbresource=self.lbresource)


    def get_lbprotocols(self):

        lbprotocols = LoadBalancer.get_lbprotocols(self)

        if not lbprotocols:
            raise ImplementationErrorException("programming error")

        if not self.extensions_enabled:
            return lbprotocols

        protocol = {}
        protocol["name"] = "TCP"
        protocol["port"] = "*"
        
        lbprotocols.append(protocol)

        protocol = {}
        protocol["name"] = "UDP"
        protocol["port"] = "*"

        return lbprotocols 



    def get_lbalgorithms(self):

        lbalgorithms = LoadBalancer.get_lbalgorithms(self)

        if not lbalgorithms:
            raise ImplementationErrorException("programming error")

        if not self.extensions_enabled:
            return lbalgorithms

        algorithm = {}
        algorithm["name"] = "LEAST_PACKETS"
        lbalgorithms.append(algorithm)

        algorithm = {}
        algorithm["name"] = "LEAST_RESPONSE_TIME"
        lbalgorithms.append(algorithm)

        return lbalgorithms



    def validate_loadbalancer_object_for_add(self, loadBalancer):

        error_list = LoadBalancer.validate_loadbalancer_object_for_add(self, loadBalancer)

        if not self.extensions_enabled:
            return error_list

        if not error_list:
            error_list = []

        if self.extensions_enabled:

            if "sureConnect" in loadBalancer:
                status, errors = loadBalancer.validate_sureConnect_value()

                if not status:
                    error_list.extend(errors)

            if "backupState" in loadBalancer:   
                status, errors = loadBalancer.validate_backupState_value()

                if not status:
                    error_list.extend(errors)

        return error_list
              

        
    def validate_loadbalancer_object_for_update(self, loadBalancer):
 
        self.logger.debug("starting validate_loadbalancer_object_for_update...")

        error_list = LoadBalancer.validate_loadbalancer_object_for_update(self, loadBalancer)

        if not self.extensions_enabled:
            return error_list

        self.logger.debug(" validate_loadbalancer_object_for_update: extensions enabled")

        if not error_list:
            error_list = []

        self.logger.debug("validating extensions to object: %s" % str(loadBalancer))

        if self.extensions_enabled:

            if "sureConnect" in loadBalancer:
                status, errors = loadBalancer.validate_sureConnect_value()

                if not status:
                    error_list.extend(errors)

            if "backupState" in loadBalancer:   
                status, errors = loadBalancer.validate_backupState_value()

                if not status:
                    error_list.extend(errors)

        return error_list
             

    def _check_loadbalancer_objects_for_add(self, loadBalancers):

        error_list = []

        for loadBalancer in loadBalancers:
            errors = self.validate_loadbalancer_object_for_add(loadBalancer)
            error_list.extend(errors)

        if error_list:
            raise BadRequestException("Validation fault", "invalid object", error_list)


    def _check_loadbalancer_object_for_add(self, loadBalancer):
        error_list = self.validate_loadbalancer_object_for_add(loadBalancer)

        if error_list:
            raise BadRequestException("Validation fault", "invalid object", error_list)

    def _check_loadbalancer_object_for_update(self, loadBalancer):
        error_list = self.validate_loadbalancer_object_for_update(loadBalancer)

        if error_list:
            raise BadRequestException("Validation fault", "invalid object", error_list)


    def ListInternal(self):
        return self.adapter.list_LoadBalancers(self.tenant_id)


    def List(self, req, env):

        self.init_request_environment(req, env)

        loadBalancers = self.ListInternal()

        return self.get_listresponse(loadBalancers, req)



    def Get(self, req, env, loadBalancerId):

        self.init_request_environment(req, env)

        loadBalancer = self.adapter.get_LoadBalancer(loadBalancerId, self.tenant_id)

        return self.get_getresponse(loadBalancer, req) 


    def Add(self, req, env):

        self.init_request_environment(req, env)

        loadBalancers = self.get_loadbalancer_objects_from_request(req)

        if isinstance(loadBalancers, list): 
            self._check_loadbalancer_objects_for_add(loadBalancers)
            resp_loadBalancer = self.adapter.add_LoadBalancers(loadBalancers, self.tenant_id)  
        else:
            loadBalancer = loadBalancers
            self._check_loadbalancer_object_for_add(loadBalancer) 
            resp_loadBalancer = self.adapter.add_LoadBalancer(loadBalancer, self.tenant_id)  

        return self.get_addresponse(resp_loadBalancer, req) 
 

    def Update(self, req, env, loadBalancerId):

        self.init_request_environment(req, env)

        loadBalancer = self.get_loadbalancer_object_from_request(req)

        self._check_loadbalancer_object_for_update(loadBalancer)
 
        self.logger.debug("about to dispatch update to adaptor")

        resp_loadBalancer = self.adapter.update_LoadBalancer(loadBalancerId, loadBalancer, self.tenant_id)  

        return self.get_updateresponse(resp_loadBalancer, req)


    def Remove(self, req, env, loadBalancerId):
        self.init_request_environment(req, env)
        
        self.adapter.remove_LoadBalancer(loadBalancerId, self.tenant_id)

        return self.get_removeresponse(req)
        
    
    def Usage(self, req, env, loadBalancerId=None, period=None):
        self.init_request_environment(req, env)

        raise NotImplementedException("Usage functionality not implemented")
  

    def GetProtocols(self, req, env):
        return LoadBalancer.GetProtocols(self, req, env)
        

    def GetAlgorithms(self, req, env):
        return LoadBalancer.GetAlgorithms(self, req, env)

