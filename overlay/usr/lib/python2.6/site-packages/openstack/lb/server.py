# Copyright (c) 2010 OpenStack, LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import errno
import sys
import os
import time
import traceback
import re
from datetime import datetime
from urllib import unquote


from webob import Request, Response
from webob.exc import HTTPOk, HTTPAccepted, HTTPBadRequest, HTTPConflict, \
    HTTPCreated, HTTPForbidden, HTTPInternalServerError, \
    HTTPMethodNotAllowed, HTTPNoContent, HTTPNotFound, HTTPPreconditionFailed, \
    HTTPNotImplemented, HTTPServiceUnavailable, HTTPRequestEntityTooLarge, \
    HTTPUnprocessableEntity, HTTPUnauthorized
import simplejson
from xml.sax import saxutils




from openstack.common.exceptions import MessageTimeout

from openstack.common.BadRequestException import BadRequestException
from openstack.common.ServiceUnavailableException import ServiceUnavailableException
from openstack.common.NotImplementedException import NotImplementedException
from openstack.common.ItemNotFoundException import ItemNotFoundException
from openstack.common.OverLimitException import OverLimitException
from openstack.common.ImmutableEntityException import ImmutableEntityException
from openstack.common.UnprocessableEntityException import UnprocessableEntityException
from openstack.common.LoadBalancerFaultException import LoadBalancerFaultException

from openstack.common.utils import get_logger, get_param, split_path, storage_directory, hash_path
from openstack.common.healthcheck import healthcheck


from openstack.lb.LoadBalancerService import LoadBalancerService
from openstack.lb.LBNode import LBNode
from openstack.lb.LBVirtualIP import LBVirtualIP
from openstack.lb.LBAccessList import LBAccessList
from openstack.lb.LBHealthMonitor import LBHealthMonitor
from openstack.lb.LBSessionPersistence import LBSessionPersistence
from openstack.lb.LBConnectionLogging import LBConnectionLogging
from openstack.lb.LBConnectionThrottle import LBConnectionThrottle


MAX_COMPONENTS_IN_URL = 50


class LBController(object):
    """WSGI controller for the LB server."""
    log_name = 'loadbalancer'

    """ This dictionary describes valid containments in a path of a URL"""
    """ Each key in the dictionary corresponds to a component value of the path, with """
    """ the values being the valid component values that can follow it. """
 

    resource_hierarchy={
                          '/': {
                                 'loadbalancers':
                                                   {
                                                    'GET' : 'self.get_lbservice().GetLoadBalancer().List(req, env)',
                                                    'POST' : 'self.get_lbservice().GetLoadBalancer().Add(req, env)'
                                                   }
                                                 
                               },
                         
			  'loadbalancers':{
                                     	   'usage':
                                                    {
                                                      'GET' : 'self.get_lbservice().GetLoadBalancer().Usage(req, env)'
                                                    },
                                                    
                                                   
                                           'protocols':
                                                        {
                                                          'GET' : 'self.get_lbservice().GetLoadBalancer().GetProtocols(req, env)'
                                                        },

                                           '%{loadBalancerId}':
                                                              {
                                                                'GET' : 'self.get_lbservice().GetLoadBalancer().Get(req, env, %{loadBalancerId})', 
                                                                'DELETE' : 'self.get_lbservice().GetLoadBalancer().Remove(req, env, %{loadBalancerId})',
                                                                'PUT' : 'self.get_lbservice().GetLoadBalancer().Update(req, env, %{loadBalancerId})'
                                                              },
					   'algorithms':
                                                         {
                                                           'GET' : 'self.get_lbservice().GetLoadBalancer().GetAlgorithms(req, env)'
                                                         },
                                                        
                                         },

                          '%{loadBalancerId}':{
                                              'nodes':
                                                       {
                                                         'GET' : 'self.get_lbservice().GetLBNode().List(req, env, %{loadBalancerId})', 
                                                         'POST' : 'self.get_lbservice().GetLBNode().Add(req, env, %{loadBalancerId}, req.body)'
                                                       },
                                                      
                                              'virtualips':
                                                            {
                                                             'GET' : 'self.get_lbservice().GetLBVirtualIP().List(req, env, %{loadBalancerId})'
                                                            },
                                                           
                                              'accesslist':
                                                            {
                                                              'GET' : 'self.get_lbservice().GetLBAccessList().List(req, env, %{loadBalancerId})',
                                                              'POST': 'self.get_lbservice().GetLBAccessList().Add(req, env, %{loadBalancerId}, req.body)',
                                                              'DELETE' : 'self.get_lbservice().GetLBAccessList().Remove(req, env, %{loadBalancerId})'
                                                            },
                                                          
                                              'healthmonitor':
                                                               {
                                                                'GET' : 'self.get_lbservice().GetLBHealthMonitor().Get(req, env, %{loadBalancerId})',
                                                                'PUT' : 'self.get_lbservice().GetLBHealthMonitor().Update(req, env, %{loadBalancerId}, req.body)',
                                                                'DELETE' : 'self.get_lbservice().GetLBHealthMonitor().Remove(req, env, %{loadBalancerId})'
                                                               },
                                                          
                                              'sessionpersistence':
                                                                    {
                                                                     'GET' : 'self.get_lbservice().GetLBSessionPersistence().Get(req, env, %{loadBalancerId})',
                                                                     'PUT' : 'self.get_lbservice().GetLBSessionPersistence().Set(req, env, %{loadBalancerId}, req.body)',
                                                                     'DELETE' : 'self.get_lbservice().GetLBSessionPersistence().Remove(req, env, %{loadBalancerId})'
                                                                    },

                                              'connectionthrottle':
                                                                    {
                                                                     'GET' : 'self.get_lbservice().GetLBConnectionThrottle().Get(req, env, %{loadBalancerId})',
                                                                     'PUT' : 'self.get_lbservice().GetLBConnectionThrottle().Set(req, env, %{loadBalancerId}, req.body)',
                                                                     'DELETE' : 'self.get_lbservice().GetLBConnectionThrottle().Remove(req, env, %{loadBalancerId})'
                                                                   },
                                                                  
					      'connectionlogging':
                                                                   {
                                                                     'GET' : 'self.get_lbservice().GetLBConnectionLogging().Get(req, env, %{loadBalancerId})',
                                                                     'PUT' : 'self.get_lbservice().GetLBConnectionLogging().Set(req, env, %{loadBalancerId}, req.body)',
                                                                   },
                                                                  		
					      'usage':
                                                        {
                                                          'GET' : 'self.get_lbservice().GetLoadBalancer().Usage(req, env, loadBalancerId=%{loadBalancerId})'
                                                        }
                                            },
                          'nodes': {
                                     '%{nodeId}':
                                                {
                                                  'GET' : 'self.get_lbservice().GetLBNode().Get(req, env, %{loadBalancerId}, %{nodeId})',
                                                  'PUT' : 'self.get_lbservice().GetLBNode().Update(req, env, %{loadBalancerId}, %{nodeId}, req.body)',
                                                  'DELETE' : 'self.get_lbservice().GetLBNode().Remove(req, env, %{loadBalancerId}, %{nodeId})'
                                                }
				   },

			  'virtualips':{   
					 '%{virtualIpId}':
                                                         {
                                                           'DELETE' : 'self.get_lbservice().GetLBVirtualIP().Remove(req, env, %{loadBalancerId}, %{virtualIpId})'
                                                         }
				       },	
                          'usage':{
				   'current':
                                              {
                                               'GET' : 'self.get_lbservice().GetLoadBalancer().Usage(req, env, loadBalancerId=%{loadBalancerId},period="current")'
                                              }
                                  },
    
			  'accesslist': {
					 '%{networkItemId}':
                                                            {
                                                              'DELETE' : 'self.get_lbservice().GetLBAccessList().Remove(req, env, %{loadBalancerId}, %{networkItemId})'
                                                            }
					}
		        }


    def __init__(self, conf, configParser):
        self.logger = get_logger(conf, self.log_name)

        self.lbservice = LoadBalancerService.SetUp(self.logger, configParser) 



    def replace_variables(self, req, call_pattern, variables):

        regex = re.compile(r'(%{[^\s}]*})')

        for match in regex.finditer(call_pattern):
             var_name = match.group(1)
             var_value = "'" + variables[var_name] + "'"   

             if var_value != None:
                 call_pattern = call_pattern.replace(var_name, var_value)
             else:
                self.logger.debug("Assertion Error: In replace_variables, No variable value for %s in url %s" % (var_name, req.url))
                raise AssertionError('No variable value for %s in url %s' % (var_name, req.url))

        return call_pattern



    def get_lbservice(self):
        return self.lbservice


    def get_error_body(self, req, error):

        content_type = req.headers.get('Accept')

        if "xml" in content_type:
            content_type = 'application/xml'   
            detail = error.get_as_xml()
        else:
            content_type = 'application/json'   
            detail = error.get_as_json()

        return content_type, detail


    def make_service_call(self, req, env, method_dict, variables):

        try:
            req_method = req.method.upper()
  
            call_pattern=method_dict[req_method]

            call_pattern = self.replace_variables(req, call_pattern, variables)

            self.logger.debug("Call on resource is: %s" % str(call_pattern) )

            response = eval(call_pattern)

        except BadRequestException as error:

            content_type, detail = self.get_error_body(req, error) 
 
            return HTTPBadRequest(body=detail, content_type=content_type, request=req)

        except NotImplementedException as error:

            content_type, detail = self.get_error_body(req, error) 
 
            return HTTPNotImplemented(body=detail, content_type=content_type, request=req)
		                                            
        except ServiceUnavailableException as error:

            content_type, detail = self.get_error_body(req, error) 
 
	    return HTTPInternalServerError(body=detail, content_type=content_type, request=req)

        except ItemNotFoundException as error:

            content_type, detail = self.get_error_body(req, error) 
 
            return HTTPNotFound(body=detail, content_type=content_type, request=req)

        except OverLimitException as error:

            content_type, detail = self.get_error_body(req, error) 
 
            return HTTPRequestEntityTooLarge(body=detail, content_type=content_type, request=req)

        except ImmutableEntityException as error:

            content_type, detail = self.get_error_body(req, error) 
 
            return HTTPUnprocessableEntity(body=detail, content_type=content_type, request=req)
		                                            
        except LoadBalancerFaultException as error:

            content_type, detail = self.get_error_body(req, error) 
 
            return HTTPUnauthorized(body=detail, content_type=content_type, request=req)

		                                            
        except Exception, msg:

            exc_type, exc_value, exc_tb = sys.exc_info()

            tb = traceback.format_exception(exc_type, exc_value, exc_tb)

            tb.reverse()

            tb_str = ''.join(tb) 

            self.logger.debug("cannot eval(%s) because %s. Traceback: %s" % (call_pattern, msg, tb_str))

            error = ServiceUnavailableException("The Load Balancing Service is currently unavailable." +
                                                " Please contact support") 

            content_type, detail = self.get_error_body(req, error) 

            return HTTPInternalServerError(body=detail, content_type=content_type, request=req)
		                                            

        return response



    def create_response_for_bad_request_url(self, req):

        error = BadRequestException("Message Format", "Invalid URL", 
                                                    "URL %s is not valid for this service" %  req.url) 
                                                     
        content_type, detail = self.get_error_body(req, error) 
 
	return HTTPBadRequest(body=detail, content_type=content_type, request=req)



    def create_response_for_bad_httpmethod_for_url(self, req):

        self.logger.debug("Bad request: HTTP method %s is not valid for this URL" % req.method.upper())
  
       
        error = UnprocessableEntityException("HTTP Method %s is not processable by this resource" % req.method.upper()) 

        content_type, detail = self.get_error_body(req, error) 

        return HTTPBadRequest(body=detail, content_type=content_type, request=req)


 
    def process_url(self, req, env, path_list, index, key, method_dict, variables):

	req_method = req.method.upper()
	 
	if method_dict != None:
            http_methods = method_dict.keys()
        else:
            http_methods = None


        if index == -1:
            key_dict = LBController.resource_hierarchy['/']
	else:
            self.logger.info("examining key %s" % key)

            if key in LBController.resource_hierarchy:
                key_dict = LBController.resource_hierarchy[key]
            else:
                key_dict = None
        
        component = path_list[index+1]
        
        if component:
            component = component.strip() 
 
        if not component:
	    self.logger.debug("path component of index %s is None" % (index+1))

            if not http_methods or not(req_method in http_methods):
                return self.create_response_for_bad_httpmethod_for_url(req)

            return self.make_service_call(req, env, method_dict, variables)               

	try:

            self.logger.info("path_list[%d] is %s" % (index+1, component))

            if key_dict == None:
                return self.create_response_for_bad_request_url(req)

		          
            for key2 in key_dict: 
                if key2 == component:
	            break
	    else:
                for key2 in key_dict: 
		    if key2.startswith('%{'):
		        variables[key2] = component
	                break
                else:
                    return self.create_response_for_bad_request_url(req)

            method_dict = key_dict[key2]

	    return self.process_url(req, env, path_list, index+1, key2, method_dict, variables)
		        
        except IndexError:
            self.logger.info("path_list[%d] doesn't exist" % (index+1))

            if not(req_method in http_methods):
                return self.create_response_for_bad_httpmethod_for_url(req)


    def __call__(self, env, start_response):

        req = Request(env)
        path_list = split_path(unquote(req.path), 0, MAX_COMPONENTS_IN_URL)

        if path_list is None or path_list[0] is None:
            path_list=[]
            path_list.append("/")


        env['api-version'] = path_list[0]
        env['account'] = path_list[1]

        request_uri = '/' + '/'.join([s for s in path_list[2:] if not s is None])

        env['request-uri'] = request_uri

        self.logger.debug("request-uri is: " + request_uri)

        res= self.process_url(req, env, path_list[2:], -1, None, None, {})

        return res(env, start_response)


