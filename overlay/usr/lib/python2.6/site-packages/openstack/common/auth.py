# Copyright (c) 2010 OpenStack, LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ConfigParser import ConfigParser, NoOptionError
import os
import time

from webob.request import Request
from webob.exc import HTTPUnauthorized, HTTPPreconditionFailed, HTTPServiceUnavailable
from eventlet.timeout import Timeout

from openstack.common.utils import split_path
from openstack.common.bufferedhttp import http_connect_raw as http_connect

from openstack.common.LoadBalancerFaultException import LoadBalancerFaultException
from openstack.common.ServiceUnavailableException import ServiceUnavailableException
from openstack.common.BadRequestException import BadRequestException


class DevAuthMiddleware(object):
    """
    Auth Middleware that uses the dev auth server
    """

    def __init__(self, app, conf, **kwargs):
        self.app = app
        self.conf = conf
 
        if 'memcache_client' in kwargs.keys():
            self.memcache_client = kwargs['memcache_client']
        else:
            self.memcache_client = None 

        if 'logger' in kwargs.keys():
            self.logger = kwargs['logger']
        else:
            self.logger = get_logger(conf, "")  

        self.auth_host = conf.get('ip', '127.0.0.1')
        self.auth_port = int(conf.get('port', 11000))
        self.timeout = int(conf.get('node_timeout', 10))


    def get_error_body(self, req, error):

        content_type = req.headers.get('Accept')

        if "xml" in content_type:
            content_type = 'application/xml'   
            detail = error.get_as_xml()
        else:
            content_type = 'application/json'   
            detail = error.get_as_json()

        return content_type, detail


    def create_response_for_bad_request_url(self, req):

        error = BadRequestException("Message Format", "Invalid URL", "URL %s is not valid for this service" %  req.url)
                                                                    
        content_type, detail = self.get_error_body(req, error) 
 
	return HTTPBadRequest(body=detail, content_type=content_type, request=req)



    def create_response_for_missing_auth_token(self, req):

        error = LoadBalancerFaultException("Missing authentication token. Please provide the authentication token in the X-Auth-Token header of the request")
                                                     
        content_type, detail = self.get_error_body(req, error) 
 
	return HTTPUnauthorized(body=detail, content_type=content_type, request=req)



    def create_response_for_invalid_auth_token(self, req):

        error = LoadBalancerFaultException("Invalid authentication token. Please renew")
                                                     
        content_type, detail = self.get_error_body(req, error) 
 
	return HTTPUnauthorized(body=detail, content_type=content_type, request=req)

    def create_response_for_authservice_unavailable(self, req, error):
                                                     
        content_type, detail = self.get_error_body(req, error) 
 
	return HTTPServiceUnavailable(body=detail, content_type=content_type, request=req)



    def __call__(self, env, start_response):

        req = Request(env)

        if req.path != '/healthcheck':
            #if 'x-storage-token' in req.headers and \
            #        'x-auth-token' not in req.headers:
            #    req.headers['x-auth-token'] = req.headers['x-storage-token']

            version, account, rest  = split_path(req.path, 1, 3, True)

            if account is None:
                res = self.create_response_for_bad_request_url(req)
                return res(env, start_response)
                    

            #if not req.headers.get('x-auth-token'):
            #    res = self.create_response_for_missing_auth_token(req)
            #    return res(env, start_response)
                    
            #try: 
            #    if not self.auth(account, req.headers['x-auth-token']):
            #        res = self.create_response_for_invalid_auth_token(req)
            #        return res(env, start_response)

            #except ServiceUnavailableException as error:
            #    res = self.create_response_for_authservice_unavailable(req, error)
            #    return res(env, start_response)

  
            # If we get here, then things should be good.
            return self.app(env, start_response)



    def auth(self, account, token):
        """
        Dev authorization implmentation

        :param account: account name
        :param token: auth token

        :returns: True if authorization is successful, False otherwise
        """
        return True
        key = 'auth/%s/%s' % (account, token)
        now = time.time()

        if self.memcache_client:
            cached_auth_data = self.memcache_client.get(key)
        else:
            cached_auth_data = None

        if cached_auth_data:
            start, expiration = cached_auth_data
            if now - start <= expiration:
                return True
        try:
            with Timeout(self.timeout):
                """
                conn = http_connect(self.auth_host, self.auth_port, 'GET',
                    '/token/%s/%s' % (account, token), ssl=True)
                """
                conn = http_connect(self.auth_host, self.auth_port, 'GET',
                    '/token/%s' % token, ssl=True)
                resp = conn.getresponse()
                resp.read()
                conn.close()
                if resp.status == 204:
                    validated = float(resp.getheader('x-auth-ttl'))
                else:
                    validated = False
                
        except:
            self.logger.exception('auth_host: %s' % self.auth_host)
            self.logger.exception('auth_port: %s' % self.auth_port)
            self.logger.exception('ERROR with auth')
            raise ServiceUnavailableException("The Auth Service is currently unavailable. Please try later")


        if not validated:
            return False
        else:
            val = (now, validated)

            if self.memcache_client:
                self.memcache_client.set(key, val, timeout=validated)

            return True
